mod PLC-MERGED-CHECKSAT is
  inc PLC-CONCRETE-CHECKSAT .
  inc PLC-SYMBOLIC-CHECKSAT .
endm

mod PLC-MERGED-ARITHMETIC is
  inc PLC-CONCRETE-ARITHMETIC .
  inc PLC-SYMBOLIC-ARITHMETIC .
endm

mod MERGED-DATA-CONVERSION is
  inc SYMBOLIC-DATA-CONVERSION .
  inc CONCRETE-DATA-CONVERSION .
endm

mod MERGED-ARITHMETIC-FUNCTIONS is
  inc SYMBOLIC-ARITHMETIC-FUNCTIONS .
  inc CONCRETE-ARITHMETIC-FUNCTIONS .
endm

mod MERGED-UTIL is
  inc SYMBOLIC-UTIL .
endm

mod MERGED-SEMANTIC-CONVERSION is 
  inc SYMBOLIC-SEMANTIC-CONVERSION .
  inc CONCRETE-SEMANTIC-CONVERSION .
endm

mod OPERATION-BETWEEN-CONCRETE-SYMBOLIC is
  inc PLC-MERGED-PRIMITIVES .
  inc PLC-MERGED-PRIMITIVE-SYN2SEM-SEM2SYN .

  vars IE1 : IntegerExpr .
  vars RE1 : RealExpr .
  vars BE1 : BooleanExpr .

  vars B1 : Bool .
  vars R1 : Rat .
  vars I1 : Int .

  var V : SemanticValue .

  op con2sym : SemanticValue -> SemanticValue [memo] .
  eq con2sym([I1]) = [ convertIntToInteger(I1) ] .
  eq con2sym([R1]) = [ convertRatToReal(R1) ] .
  eq con2sym([B1]) = [ convertBoolToBoolean(B1) ] .

  eq [I1] + [IE1] = con2sym([I1]) + [IE1] .
  eq [IE1] + [I1] = [IE1] + con2sym([I1]) .
  eq [I1] - [IE1] = con2sym([I1]) - [IE1] .
  eq [IE1] - [I1] = [IE1] - con2sym([I1]) .
  eq [I1] * [IE1] = con2sym([I1]) * [IE1] .
  eq [IE1] * [I1] = [IE1] * con2sym([I1]) .
  eq [I1] / [IE1] = con2sym([I1]) / [IE1] .
  eq [IE1] / [I1] = [IE1] / con2sym([I1]) .
  eq [I1] % [IE1] = con2sym([I1]) % [IE1] .
  eq [IE1] % [I1] = [IE1] % con2sym([I1]) .
  eq [I1] < [IE1] = con2sym([I1]) < [IE1] .
  eq [IE1] < [I1] = [IE1] < con2sym([I1]) .
  eq [I1] > [IE1] = con2sym([I1]) > [IE1] .
  eq [IE1] > [I1] = [IE1] > con2sym([I1]) .
  eq [I1] <= [IE1] = con2sym([I1]) <= [IE1] .
  eq [IE1] <= [I1] = [IE1] <= con2sym([I1]) .
  eq [I1] >= [IE1] = con2sym([I1]) >= [IE1] .
  eq [IE1] >= [I1] = [IE1] >= con2sym([I1]) .
  eq [I1] ==== [IE1] = con2sym([I1]) ==== [IE1] .
  eq [IE1] ==== [I1] = [IE1] ==== con2sym([I1]) .
  eq [I1] <> [IE1] = con2sym([I1]) <> [IE1] .
  eq [IE1] <> [I1] = [IE1] <> con2sym([I1]) .

  eq T[I1] + T[IE1] = T[ convertIntToInteger(I1) ] + T[IE1] .
  eq T[IE1] + T[I1] = T[IE1] + T[ convertIntToInteger(I1) ] .
  eq T[I1] - T[IE1] = T[ convertIntToInteger(I1) ] - T[IE1] .
  eq T[IE1] - T[I1] = T[IE1] - T[ convertIntToInteger(I1) ] .
  eq T[I1] * T[IE1] = T[ convertIntToInteger(I1) ] * T[IE1] .
  eq T[IE1] * T[I1] = T[IE1] * T[ convertIntToInteger(I1) ] .
  eq T[I1] / T[IE1] = T[ convertIntToInteger(I1) ] / T[IE1] .
  eq T[IE1] / T[I1] = T[IE1] / T[ convertIntToInteger(I1) ] .
  eq T[I1] % T[IE1] = T[ convertIntToInteger(I1) ] % T[IE1] .
  eq T[IE1] % T[I1] = T[IE1] % T[ convertIntToInteger(I1) ] .
  eq T[I1] < T[IE1] = T[ convertIntToInteger(I1) ] < T[IE1] .
  eq T[IE1] < T[I1] = T[IE1] < T[ convertIntToInteger(I1) ] .
  eq T[I1] > T[IE1] = T[ convertIntToInteger(I1) ] > T[IE1] .
  eq T[IE1] > T[I1] = T[IE1] > T[ convertIntToInteger(I1) ] .
  eq T[I1] <= T[IE1] = T[ convertIntToInteger(I1) ] <= T[IE1] .
  eq T[IE1] <= T[I1] = T[IE1] <= T[ convertIntToInteger(I1) ] .
  eq T[I1] >= T[IE1] = T[ convertIntToInteger(I1) ] >= T[IE1] .
  eq T[IE1] >= T[I1] = T[IE1] >= T[ convertIntToInteger(I1) ] .
  eq T[I1] ==== T[IE1] = T[ convertIntToInteger(I1) ] ==== T[IE1] .
  eq T[IE1] ==== T[I1] = T[IE1] ==== T[ convertIntToInteger(I1) ] .
  eq T[I1] <> T[IE1] = T[ convertIntToInteger(I1) ] <> T[IE1] .
  eq T[IE1] <> T[I1] = T[IE1] <> T[ convertIntToInteger(I1) ] .

  eq [R1] + [RE1] = [ convertRatToReal(R1) ] + [RE1] .
  eq [RE1] + [R1] = [RE1] + [ convertRatToReal(R1) ] .
  eq [R1] - [RE1] = [ convertRatToReal(R1) ] - [RE1] .
  eq [RE1] - [R1] = [RE1] - [ convertRatToReal(R1) ] .
  eq [R1] * [RE1] = [ convertRatToReal(R1) ] * [RE1] .
  eq [RE1] * [R1] = [RE1] * [ convertRatToReal(R1) ] .
  eq [R1] / [RE1] = [ convertRatToReal(R1) ] / [RE1] .
  eq [RE1] / [R1] = [RE1] / [ convertRatToReal(R1) ] .
  eq [R1] % [RE1] = [ convertRatToReal(R1) ] % [RE1] .
  eq [RE1] % [R1] = [RE1] % [ convertRatToReal(R1) ] .

  eq [R1] < [RE1] = [ convertRatToReal(R1) ] < [RE1] .
  eq [RE1] < [R1] = [RE1] < [ convertRatToReal(R1) ] .
  eq [R1] > [RE1] = [ convertRatToReal(R1) ] > [RE1] .
  eq [RE1] > [R1] = [RE1] > [ convertRatToReal(R1) ] .
  eq [R1] <= [RE1] = [ convertRatToReal(R1) ] <= [RE1] .
  eq [RE1] <= [R1] = [RE1] <= [ convertRatToReal(R1) ] .
  eq [R1] >= [RE1] = [ convertRatToReal(R1) ] >= [RE1] .
  eq [RE1] >= [R1] = [RE1] >= [ convertRatToReal(R1) ] .
  eq [R1] ==== [RE1] = [ convertRatToReal(R1) ] ==== [RE1] .
  eq [RE1] ==== [R1] = [RE1] ==== [ convertRatToReal(R1) ] .
  eq [R1] <> [RE1] = [ convertRatToReal(R1) ] <> [RE1] .
  eq [RE1] <> [R1] = [RE1] <> [ convertRatToReal(R1) ] .

  eq [B1] ==== [BE1] = con2sym([B1]) ==== [BE1] .
  eq [BE1] ==== [B1] = con2sym([B1]) ==== [BE1] .
  eq [B1] <> [BE1]= con2sym([B1]) <> [BE1] .
  eq [BE1] <> [B1] = con2sym([B1]) <> [BE1] .

  eq [B1] AND [BE1] = con2sym([B1]) AND [BE1] .
  eq [BE1] AND [B1] = [BE1] AND con2sym([B1]) .

  eq [B1] OR [BE1] = con2sym([B1]) OR [BE1] .
  eq [BE1] OR [B1] = [BE1] OR con2sym([B1]) .
endm

mod MERGE is
  inc OPERATION-BETWEEN-CONCRETE-SYMBOLIC .

  sort DataType .
  ops Real Boolean Integer Time : -> DataType [ctor] .

  --- merge var generation
  op type : SemanticValue ~> DataType .
  eq type([BEX:BooleanExpr]) = Boolean .
  eq type([BEX:Bool]) = Boolean .
  eq type([REX:RealExpr]) = Real .
  eq type([REX:Rat]) = Real .
  eq type([IEX:IntegerExpr]) = Integer .
  eq type([IEX:Int]) = Integer .
  eq type(T[IEX:IntegerExpr]) = Time .
  eq type(T[IEX:Int]) = Time .

  op merge--_ : Nat -> SMTVarId [ctor] .

  op fresh? : SemanticValue Nat ~> Bool .
  eq fresh?([r(merge-- N1:Nat)], N2:Nat) = N1:Nat >= N2:Nat .
  eq fresh?([b(merge-- N1:Nat)], N2:Nat) = N1:Nat >= N2:Nat .
  eq fresh?([i(merge-- N1:Nat)], N2:Nat) = N1:Nat >= N2:Nat .
  eq fresh?(T[i(merge-- N1:Nat)], N2:Nat) = N1:Nat >= N2:Nat .
  eq fresh?(E:SemanticValue, N:Nat) = false [owise] .
  sort ExpGenPair .
  op @@ : SemanticValue Nat -> ExpGenPair [ctor] .
  op #gen : Nat DataType ~> ExpGenPair .
  op mergeVar : -> SMTVarId [ctor] .

  var N : Nat .
  eq #gen(N, Real) = @@([r(merge-- N)], s(N)) .
  eq #gen(N, Integer) = @@([i(merge-- N)], s(N)) .
  eq #gen(N, Time) = @@(T[i(merge-- N)], s(N)) .
  eq #gen(N, Boolean) = @@([b(merge-- N)], s(N)) .


  sorts ResultExpMerge .
  op {_,_,_,_} : SemanticValue SemanticValue SemanticValue Nat -> ResultExpMerge [ctor] .
  op symMerge : SemanticValue SemanticValue Nat Nat ~> ResultExpMerge .

  vars E E' E'' V : SemanticValue .
  vars EL EL' EL'' : SemanticValue .
  vars B B' B1 B1' : SemanticValue .
  vars GEN GEN# GEN' GEN'' : Nat .

  eq symMerge(E, E, GEN, GEN#) = {E, [(true).Boolean], [(true).Boolean], GEN} .

 ceq symMerge(V, E, GEN, GEN#) = {V, [(true).Boolean], V ==== E, GEN}
  if V =/= E /\ fresh?(V, GEN#) /\ type(V) == type(E) .
   ceq symMerge(E, E', GEN, GEN#) = {V, V ==== E, V ==== E', GEN'}
  if @@(V, GEN') := #gen(GEN, type(E)) /\ type(E) == type(E') [owise] .

  sort ResultStoreMerge .
  op {_,_,_,_} : Map{Location, SemanticValue} SemanticValue SemanticValue Nat -> ResultStoreMerge [ctor] .
  op symMerge : Map{Location, SemanticValue} Map{Location, SemanticValue} Nat Nat ~> ResultStoreMerge .
  op symMerge : Map{Location, SemanticValue} Map{Location, SemanticValue} Map{Location, SemanticValue} SemanticValue SemanticValue Nat Nat ~> ResultStoreMerge .

  vars ST ST' ST'' : Map{Location, SemanticValue} .
  var KL : Location .

  eq symMerge(ST, ST', GEN, GEN#) = symMerge(ST, ST', empty, [(true).Boolean], [(true).Boolean], GEN, GEN#) .
  eq symMerge((KL |-> E, ST), (KL |-> E, ST'), ST'', B, B', GEN, GEN#)
   = symMerge(ST, ST', (ST'', KL |-> E), B, B', GEN, GEN#) .
 ceq symMerge((KL |-> E, ST), (KL |-> E', ST'), ST'', B, B', GEN, GEN#)
   = symMerge(ST, ST', (ST'', KL |-> V), B AND B1, B' AND B1', GEN', GEN#)
  if {V, B1, B1', GEN'} := symMerge(E, E', GEN, GEN#) [owise] .

  eq symMerge(empty, empty, ST, B, B', GEN, GEN#) = {ST, B, B', GEN} .

  sort ResultConfigurationMerge .

  op symMergeTwo : KConfig KConfig Nat Nat ~> KConfig .
  op symMergeTwo : KConfig KConfig KConfig SemanticValue SemanticValue Nat Nat ~> KConfig .
  var CONF CONF' CONF'' : KConfig .
  var LOG LOG' : Log .
  vars MVG MVG' : Nat .

  sorts KConfigSet NeKConfigSet .
  subsort KConfig < NeKConfigSet .
  subsort NeKConfigSet < KConfigSet .
  op emptyKCSet : -> KConfigSet [ctor] .
  op _,,_ : KConfigSet KConfigSet -> KConfigSet [ctor assoc comm id: emptyKCSet] .

  var CCS : KConfigSet .

  op maxGen : NeKConfigSet ~> Nat .
  op maxGen : KConfigSet Nat ~> Nat .

  eq maxGen(((mergeGen(MVG) CONF),, CCS)) = maxGen(CCS, MVG) .
  eq maxGen(((mergeGen(MVG) CONF),, CCS), MVG') = maxGen(CCS, max(MVG, MVG')) .
  eq maxGen(emptyKCSet, MVG) = MVG .

  eq symMergeTwo(CONF, CONF', GEN, GEN#) 
   = symMergeTwo(CONF, CONF', empty, [(true).Boolean], [(true).Boolean], GEN, GEN#) .

  vars CON CON' : SemanticValue .
 ceq symMergeTwo(store(ST) constraints(CON) CONF,
                 store(ST') constraints(CON') CONF', CONF'', B, B', GEN, GEN#)
   = symMergeTwo(constraints(CON) CONF, constraints(CON') CONF', (CONF'' store(ST'')), B AND B1, B' AND B1', GEN', GEN#)
     if {ST'', B1, B1', GEN'} := symMerge(ST, ST', GEN, GEN#) .

  eq symMergeTwo(constraints(CON) mergeGen(MVG) log(LOG) CONF'',
                 constraints(CON') mergeGen(MVG') log(LOG') CONF'', 
                 CONF, B, B', GEN, GEN#)
   = constraints((CON AND B) OR (CON' AND B')) mergeGen(GEN) log(LOG') CONF CONF'' .

  op symMerge : KConfigSet ~> KConfigSet . --- sort?
  op symMerge : KConfig KConfigSet Nat Nat ~> KConfig .

  vars CC CC' CC'' : KConfig .
  eq symMerge(emptyKCSet) = empty .
  eq symMerge(CC,, emptyKCSet) = CC .
 ceq symMerge((CC,, CCS)) = symMerge(CC, CCS, MVG, MVG) if  CCS =/= emptyKCSet /\ MVG := maxGen((CC,, CCS)) .
  eq symMerge(CC, empty, GEN, GEN#) = CC .
 ceq symMerge(CC, (CC',, CCS), GEN, GEN#) = symMerge(constraints(CON) mergeGen(GEN') CONF, CCS, GEN', GEN#)
  if constraints(CON) mergeGen(GEN') CONF := symMergeTwo(CC, CC', GEN, GEN#) .

  eq symMerge(CC, CCS, GEN, GEN#) = (CC,, symMerge(CCS)) [owise] .
endm
