view Oid from TRIV to CONFIGURATION is
  sort Elt to Oid .
endv


mod NECONFIGURATION is
  including CONFIGURATION .

  sort NEConfiguration .
  subsort NEConfiguration < Configuration .
  subsort Object < NEConfiguration .

  op __ : NEConfiguration Configuration -> NEConfiguration [ctor ditto] .
  op __ : Configuration NEConfiguration -> NEConfiguration [ctor ditto] .

  sort World .
  op {_} : Configuration -> World [ctor] .
endm

view Msg from TRIV to CONFIGURATION is
  sort Elt to Msg .
endv

mod OBJ-STRUCTURE is
  including CODE-CONFIG .
  including NECONFIGURATION .
  including MAP{PExp, Nat} * (op undefined to undefinedTimer) .
  including MAP{PExp, Bool} * (op undefined to undefinedDisable) .
  including DYNAMICS-EVALUATION .
  including PLC-CORE .

  subsort PExp < Oid .

  sort PLCMachine .
  subsort PLCMachine < NEConfiguration .

  subsort PLCMachine < Cid .
  op PLCMachine : -> PLCMachine [ctor format(! o)] .
  op proc   :_ : KConfig? -> Attribute [ctor gather(&) format(nm o d d)] .
  op state :_ : Map{PExp, SemanticValue} -> Attribute [ctor gather(&) format(nm o d d)] .
  op timer :_ : Nat -> Attribute [ctor gather(&) format(nm o d d)] .
  op actList :_ : List{PExp} -> Attribute [ctor gather(&) format(nm o d d)] .
  op senList :_ : List{PExp} -> Attribute [ctor gather(&) format(nm o d d)] .
  op flow :_ : Dynamics -> Attribute [ctor gather(&) format(nm o d d)] .
  op gen :_ : Nat -> Attribute [ctor gather(&) format(nm o d d)] .
endm

mod UTIL is
  including DYNAMICS-EVALUATION .
  including OBJ-STRUCTURE .

  op mte : NEConfiguration ~> Nat .
  op monus : Nat Nat ~> Nat .
  op enable : NEConfiguration ~> NEConfiguration .

  var PLC : Object .
  var CONF : NEConfiguration .
  var ATTRS : AttributeSet .
  var TIMER : Nat .
  var DISABLED : Map{PExp, Bool} .
  var PNAME : Pid .
  vars T T' : Nat .
  var CONF' : Configuration .
 
  eq mte(PLC CONF) = min(mte(PLC), mte(CONF)) .
  eq mte(< O:Oid : PLCMachine | timer : TIMER, ATTRS >)
   = TIMER .

  eq monus(T, T') = T - T' .
endm

mod TIMEEFFECT is
  including NECONFIGURATION .
  including UTIL .


  op timeEffect : Configuration Nat ~> Configuration .

  var KC : KConfig .
  var ATTRS : AttributeSet .
  vars STATE STATE' : Map{PExp, SemanticValue} .
  var FLOW : Dynamics .
  vars T MINT MAXT : Nat .
  var TIMER : Nat .
  var CC : SemanticValue .
  var CONF : NEConfiguration .
  var CONF' : NEConfiguration .

  eq timeEffect(none, T) = none .
  eq timeEffect(
     < O:Oid : PLCMachine | timer : TIMER, 
                            flow : FLOW,
                            state : STATE, ATTRS >, T)
   = < O:Oid : PLCMachine | timer : monus(TIMER, T),
                            flow : FLOW,
                            state : timeEffect(FLOW, STATE, T),
                            ATTRS > .
  
  eq timeEffect(CONF CONF', T) = timeEffect(CONF, T) timeEffect(CONF', T) .
endm 

mod EXECUTE is
  including TIMEEFFECT .
  including CODE-CONFIG .
  including BOOLEAN-EXPR .

  ops sense actuate : Configuration ~> Configuration .
  op actuate : Map{PExp, SemanticValue} KConfig List{PExp} ~> Map{PExp, SemanticValue} .
  op sense : KConfig Map{PExp, SemanticValue} List{PExp} ~> KConfig .
  op isAllReadyFrozen : Configuration ~> Bool . 

  var CONF : Configuration .
  vars T : Nat .
  var IM : Map{ProcessId, Nat} .
  var TIMER : Nat .
  vars X PNAME : Pid .
  var PRID : ProcessId .
  vars KC RESTI RESTT INSS : KConfig .
  var ATTRS : AttributeSet .
  var K : K .
  vars SENLIST ACTLIST : List{PExp} .
  var STATE : Map{PExp, SemanticValue} .
  vars V V' : SemanticValue .
  var MEM : Env .
  var STORE : Map{Location, SemanticValue} .
  var L : Location .
  var ENV : Env .
  var STACK : ProgramStack .
  var N : Nat .
  var PL : List{ProcessId} .

--- string conversion
  eq k(thisBlock ~> K) callStack(ENV :: STACK)
     inss(ins(mem(ENV) iname(PNAME) RESTI) INSS)
   = k([string(PNAME)] ~> K) callStack(ENV :: STACK)
     inss(ins(mem(ENV) iname(PNAME) RESTI) INSS) .

  eq < O:PExp : PLCMachine | gen : N, proc : k(boolUserInput ~> K) KC, ATTRS >
   = < O:PExp : PLCMachine | gen : s N, proc : k([b(smtv(O:PExp, N))] ~> K) KC, ATTRS > .

 crl [envTick] :
     {CONF} => {timeEffect(CONF, T)}
  if T := mte(CONF) /\ T > 0 .

 crl [start] :
     {CONF} => {enable(sense(actuate(CONF)))}
  if isAllReadyFrozen(CONF) .

  eq [end] :
     < O:Oid : PLCMachine | proc : k(.K) pList(nilProcIds) KC, ATTRS > 
   = < O:Oid : PLCMachine | proc : [k(@end) pList(nilProcIds) KC], ATTRS > .


  eq isAllReadyFrozen(
     < O:Oid : PLCMachine | timer : 0, proc : [KC], ATTRS > CONF)
   = isAllReadyFrozen(CONF) .

  eq isAllReadyFrozen(
     < O:Oid : PLCMachine | timer : 0, proc : KC, ATTRS > CONF)
   = false .

  eq isAllReadyFrozen(CONF) = true [owise] .

  eq actuate(
     < O:Oid : PLCMachine | timer : 0,
                            proc : [KC],
                            state : STATE,
                            actList : ACTLIST,
                            ATTRS > CONF) 
   = < O:Oid : PLCMachine | timer : 0,
                            proc : [KC],
                            state : actuate(STATE, KC, ACTLIST),
                            actList : ACTLIST,
                            ATTRS > actuate(CONF) .
  eq sense(
     < O:Oid : PLCMachine | timer : 0,
                            proc : [KC],
                            state : STATE,
                            senList : SENLIST,
                            ATTRS > CONF) 
   = < O:Oid : PLCMachine | timer : 0,
                            proc : [sense(KC, STATE, SENLIST)],
                            state : STATE,
                            senList : SENLIST,
                            ATTRS > sense(CONF) .

  eq enable(
     < O:Oid : PLCMachine | timer : 0, proc : [cycleTime(T) KC], ATTRS > CONF)
   = < O:Oid : PLCMachine | timer : T, proc : cycleTime(T) KC, ATTRS >
     enable(CONF) .

  eq actuate(CONF) = CONF [owise] .
  eq sense(CONF) = CONF [owise] .
  eq enable(CONF) = CONF [owise] .

  eq actuate(((X ||-> V), STATE), 
             store(((L |-> V'), STORE))
             inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
             (X, ACTLIST))
   = ((X ||-> V'), actuate(STATE, store(((L |-> V'), STORE))
             inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
             ACTLIST)) .

  eq actuate(STATE, KC, nilPExpList) = STATE .

  eq sense(store(((L |-> V'), STORE))
           inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
           ((X ||-> V), STATE), (X, SENLIST))
   =  sense(store(((L |-> V), STORE))
           inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
           ((X ||-> V), STATE), SENLIST) .

  eq sense(KC, STATE, nilPExpList) = KC .
endm

mod COMMUNICATION is
  including UTIL .
  including EXECUTE .

  sort Channel .
  subsort Channel < NEConfiguration .
  subsort Channel < Cid .
  sorts CMsg CMsgs .
  subsort CMsg < CMsgs .

  op Channel : -> Channel [ctor] .
  op link : Oid Oid -> Oid [ctor comm] .
  op mwrapper : Oid Oid SemanticValue SemanticValue SemanticValue -> CMsg [ctor] .
  op emptyBuffer : -> CMsgs [ctor] .
  op __ : CMsgs CMsgs -> CMsgs [ctor assoc comm id: emptyBuffer] .
  op insert : CMsgs CMsg ~> CMsgs .
  op checkMsg : CMsgs Oid PExp PExp ~> Bool .
  op validity :_ : Bool -> Attribute [ctor] .
  op buffer :_ : CMsgs -> Attribute [ctor] .

  vars O O' : PExp .
  var TARGET : SemanticValue .
  var K : K .
  vars RESTT KC : KConfig .
  vars ATTRS ATTRS' : AttributeSet .
  var BUFFER : CMsgs .
  var NEWM : CMsg .
  vars DATA DATA' SFBID RFBID : SemanticValue .
  var B : Bool .

  eq mte(< L:Oid : Channel | ATTRS >) = 1000000 .
  eq timeEffect(< L:Oid : Channel | ATTRS >, T:Nat)
   = < L:Oid : Channel | ATTRS > .

  eq insert(BUFFER mwrapper(O, O', SFBID, RFBID, DATA'), mwrapper(O, O', SFBID, RFBID, DATA))
   = BUFFER mwrapper(O, O', SFBID, RFBID, DATA) .
  eq insert(BUFFER, NEWM) = BUFFER NEWM [owise] .
  eq checkMsg(BUFFER mwrapper(O, O', SFBID, RFBID, DATA), O, SFBID, RFBID) = true .
  eq checkMsg(BUFFER, O, SFBID, RFBID) = false [owise] .

 crl [con-succ] :
     < O : PLCMachine | proc : k(connectRequest(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, ATTRS' >
  => < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
  if O' == sem2syn(TARGET) .

 crl [con-back] :
     < O : PLCMachine | proc : k(connectRequest(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
  => < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
  if O' == sem2syn(TARGET) .

---(
  rl [con-fail] : --- failure, denial, abort 
     < O : PLCMachine | proc : k(connectRequest(O') ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, ATTRS' >
  => < O : PLCMachine | proc : k(K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' > .
---)

 crl [discon-vol]:
     < O : PLCMachine | proc : k(disconnect(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
  => < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, ATTRS' >
  if O' == sem2syn(TARGET) .


 crl [isConnected]:
     < O : PLCMachine | proc : k(isConnected(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : B, ATTRS' >
  => < O : PLCMachine | proc : k(if B then TRUE else FALSE fi ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : B, ATTRS' >
  if O' == sem2syn(TARGET) .

---(
  rl [discon-unvol] :
     < link(O, O') : Channel | validity : true, ATTRS' >
  => < link(O, O') : Channel | validity : false, ATTRS' > .
---)
 crl [sendData] :
     < O : PLCMachine | proc : k(sendData(TARGET, SFBID, RFBID, DATA) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' >
  => < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : insert(BUFFER, mwrapper(O, O', SFBID, RFBID, DATA)), ATTRS' >
     if O' == sem2syn(TARGET) .

 crl [sendData-fail] :
     < O : PLCMachine | proc : k(sendData(TARGET, SFBID, RFBID, DATA) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
  => < O : PLCMachine | proc : k(FALSE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
     if O' == sem2syn(TARGET) .

 crl [rcvData] :
     < O : PLCMachine | proc : k(rcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : (BUFFER mwrapper(O', O, SFBID, RFBID, DATA)), ATTRS' >
  => < O : PLCMachine | proc : k(sem2syn(DATA) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' >
     if O' == sem2syn(TARGET) .

 crl [rcv-fail] :
     < O : PLCMachine | proc : k(rcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
  => < O : PLCMachine | proc : k(rcvError ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
     if O' == sem2syn(TARGET) .

 crl [rcv-noMsg] :
     < O : PLCMachine | proc : k(rcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' >
  => < O : PLCMachine | proc : k(rcvError ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' > 
  if O' == sem2syn(TARGET) /\ not checkMsg(BUFFER, O', SFBID, RFBID) .
endm

