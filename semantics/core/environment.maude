view Oid from TRIV to CONFIGURATION is
  sort Elt to Oid .
endv


mod NECONFIGURATION is
  including CONFIGURATION .

  sort NEConfiguration .
  subsort NEConfiguration < Configuration .
  subsort Object < NEConfiguration .

  op __ : NEConfiguration Configuration -> NEConfiguration [ctor ditto] .
  op __ : Configuration NEConfiguration -> NEConfiguration [ctor ditto] .

  sort World .
  op {_} : Configuration -> World [ctor] .
endm

view Msg from TRIV to CONFIGURATION is
  sort Elt to Msg .
endv

mod OBJ-STRUCTURE is
  including CODE-CONFIG .
  including NECONFIGURATION .
  including MAP{PExp, Nat} * (op undefined to undefinedTimer) .
  including MAP{PExp, Bool} * (op undefined to undefinedDisable) .
  including DYNAMICS-EVALUATION .
  including PLC-CORE .

  subsort PExp < Oid .

  sort PLCMachine .
  subsort PLCMachine < NEConfiguration .

  subsort PLCMachine < Cid .
  op PLCMachine : -> PLCMachine [ctor format(! o)] .
  op proc   :_ : KConfig? -> Attribute [ctor gather(&) format(nm o d d)] .
  op state :_ : Map{PExp, SemanticValue} -> Attribute [ctor gather(&) format(nm o d d)] .
  op timer :_ : SemanticValue -> Attribute [ctor gather(&) format(nm o d d)] .
  op actList :_ : List{PExp} -> Attribute [ctor gather(&) format(nm o d d)] .
  op senList :_ : List{PExp} -> Attribute [ctor gather(&) format(nm o d d)] .
  op flow :_ : Dynamics -> Attribute [ctor gather(&) format(nm o d d)] .
  op gen :_ : Nat -> Attribute [ctor gather(&) format(nm o d d)] .
  op clock :_ : Nat -> Attribute [ctor gather(&) format(nm o d d)] .
  op envTimer :_ : Nat -> Attribute [ctor gather(&) format(nm o d d)] .

  op tgen : Nat -> NEConfiguration [ctor] .
  op tickTurn : Bool -> NEConfiguration [ctor] .
  op cconst : SemanticValue -> NEConfiguration [ctor] . 
  op dconst : SemanticValue -> NEConfiguration [ctor] . 
  op tconst : SemanticValue -> NEConfiguration [ctor] . 
endm

mod UTIL is
  including DYNAMICS-EVALUATION .
  including OBJ-STRUCTURE .

  op mte : NEConfiguration SemanticValue ~> SemanticValue .
  op monus : Nat Nat ~> Nat .
  op enable : NEConfiguration ~> NEConfiguration .

  var PLC : Object .
  var CONF : NEConfiguration .
  var ATTRS : AttributeSet .
  var TIMER : SemanticValue .
  var TE : SemanticValue .
  var DISABLED : Map{PExp, Bool} .
  var PNAME : Pid .
  vars T T' : Nat .
  var CONF' : Configuration .
 
  eq mte(PLC CONF, TE) = mte(PLC, TE) AND mte(CONF, TE) .
  eq mte(< O:Oid : PLCMachine | timer : TIMER, ATTRS >, TE)
   = TE <= TIMER .
  eq mte(CONF, TE) = [(true).Boolean] [owise] .

  eq monus(T, T') = T - T' .
endm

mod TIMEEFFECT is
  including NECONFIGURATION .
  including UTIL .


  op envTimeEffect : Configuration Nat ~> Configuration .
  op timeEffect : Configuration SemanticValue ~> Configuration .

  var KC : KConfig .
  var ATTRS : AttributeSet .
  vars STATE STATE' : Map{PExp, SemanticValue} .
  var FLOW : Dynamics .
  vars T MINT MAXT : Nat .
  vars TIMER CLOCK : Nat .
  var CC : SemanticValue .
  var CONF : NEConfiguration .
  var CONF' : NEConfiguration .

  eq envTimeEffect(none, T) = none .
  eq envTimeEffect(
     < O:Oid : PLCMachine | envTimer : TIMER,
                            clock : CLOCK, 
                            flow : FLOW,
                            state : STATE, ATTRS >, T)
   = < O:Oid : PLCMachine | envTimer : monus(TIMER, T),
                            clock : CLOCK + T,
                            flow : FLOW,
                            state : envTimeEffect(FLOW, STATE, T),
                            ATTRS > .
  
  eq envTimeEffect(CONF CONF', T) = envTimeEffect(CONF, T) envTimeEffect(CONF', T) .
  eq envTimeEffect(CONF, T) = CONF [owise] .

  op minEnv : Configuration ~> Nat .

  eq minEnv(< O:Oid : PLCMachine | envTimer : TIMER,
                                   clock : CLOCK, 
                                   flow : FLOW,
                                   state : STATE, ATTRS > CONF) = min(TIMER, minEnv(CONF)) .
  eq minEnv(CONF) = 10000000 [owise] .
endm 

mod EXECUTE is
  including TIMEEFFECT .
  including CODE-CONFIG .
  including BOOLEAN-EXPR .

  ops sense actuate : Configuration ~> Configuration .
  op actuate : Map{PExp, SemanticValue} KConfig List{PExp} ~> Map{PExp, SemanticValue} .
  op sense : KConfig Map{PExp, SemanticValue} List{PExp} ~> KConfig .
  op isAllReadyFrozen : Configuration ~> Bool . 
  op isAnyReady : Configuration ~> Bool .

  var CONF : Configuration .
  vars T : Nat .
  var IM : Map{ProcessId, Nat} .
  var TIMER : Nat .
  vars X PNAME : Pid .
  var PRID : ProcessId .
  vars KC RESTI RESTT INSS : KConfig .
  var ATTRS : AttributeSet .
  var K : K .
  vars SENLIST ACTLIST : List{PExp} .
  var STATE : Map{PExp, SemanticValue} .
  vars V V' : SemanticValue .
  var MEM : Env .
  var STORE : Map{Location, SemanticValue} .
  var L : Location .
  var ENV : Env .
  var STACK : ProgramStack .
  var N : Nat .
  var PL : List{ProcessId} .
  vars TIME' TIME : SemanticValue .
  var CONST : SemanticValue .

  op collectTimerZero : Configuration ~> SemanticValue .
--- string conversion
  eq k(thisBlock ~> K) callStack(ENV :: STACK)
     inss(ins(mem(ENV) iname(PNAME) RESTI) INSS)
   = k([string(PNAME)] ~> K) callStack(ENV :: STACK)
     inss(ins(mem(ENV) iname(PNAME) RESTI) INSS) .

  eq < O:PExp : PLCMachine | gen : N, proc : k(boolUserInput ~> K) constraints(CONST) KC, ATTRS >
   = < O:PExp : PLCMachine | gen : s N, proc : k([i(smtv(O:PExp, N))] ~> K) constraints(CONST AND (([i(smtv(O:PExp, N))] ==== [(1).Integer]) OR ([i(smtv(O:PExp, N))] ==== [(0).Integer]))) KC, ATTRS > .

  rl [tick] :
     {tconst(CONST) CONF tickTurn(true) tgen(N)} 
  => {tconst(CONST AND mte(CONF, [r(tv(N))]) AND ([r(tv(N))] >= [(0/1).Real])) timeEffect(CONF, [r(tv(N))]) tickTurn(false) tgen(s N)} .

  eq timeEffect(< O:Oid : PLCMachine | timer : TIME', ATTRS > CONF, TIME)
   = < O:Oid : PLCMachine | timer : TIME' - TIME, ATTRS > timeEffect(CONF, TIME) .

 ceq [envTick] :
     {CONF} = {envTimeEffect(CONF, minEnv(CONF))}
  if minEnv(CONF) > 0 .

 crl [start] :
     {tconst(CONST) CONF tickTurn(false)} 
  => {tconst(CONST AND collectTimerZero(CONF)) enable(sense(actuate(CONF))) tickTurn(true)}
  if isAnyReady(CONF) /\ isAllReadyFrozen(CONF) /\ checkSAT(CONST AND collectTimerZero(CONF)) .

  eq [end] :
     < O:Oid : PLCMachine | proc : k(.K) pList(nilProcIds) KC, ATTRS > 
   = < O:Oid : PLCMachine | proc : [k(@end) pList(nilProcIds) KC], ATTRS > .

  eq isAnyReady(< O:Oid : PLCMachine | envTimer : 0, ATTRS > CONF)
   = true .

  eq isAnyReady(CONF) = false [owise] .

  eq isAllReadyFrozen(
     < O:Oid : PLCMachine | envTimer : 0, proc : [KC], ATTRS > CONF)
   = isAllReadyFrozen(CONF) .

  eq isAllReadyFrozen(
     < O:Oid : PLCMachine | envTimer : 0, proc : KC, ATTRS > CONF)
   = false .

  eq isAllReadyFrozen(CONF) = true [owise] .


  eq collectTimerZero(< O:Oid : PLCMachine | timer : TIME, ATTRS > CONF)
   = TIME ==== [(0).Nat] AND collectTimerZero(CONF) .

  eq collectTimerZero(CONF) = [(true).Boolean] [owise] .

  eq actuate(
     < O:Oid : PLCMachine | envTimer : 0,
                            proc : [KC],
                            state : STATE,
                            actList : ACTLIST,
                            ATTRS > CONF) 
   = < O:Oid : PLCMachine | envTimer : 0,
                            proc : [KC],
                            state : actuate(STATE, KC, ACTLIST),
                            actList : ACTLIST,
                            ATTRS > actuate(CONF) .
  eq sense(
     < O:Oid : PLCMachine | envTimer : 0,
                            proc : [KC],
                            state : STATE,
                            senList : SENLIST,
                            ATTRS > CONF) 
   = < O:Oid : PLCMachine | envTimer : 0,
                            proc : [sense(KC, STATE, SENLIST)],
                            state : STATE,
                            senList : SENLIST,
                            ATTRS > sense(CONF) .

  eq enable(
     < O:Oid : PLCMachine | envTimer : 0, timer : TT:SemanticValue, proc : [cycleTime(T) KC], ATTRS > CONF)
   = < O:Oid : PLCMachine | envTimer : T, timer : [T], proc : cycleTime(T) KC, ATTRS >
     enable(CONF) .

  eq actuate(CONF) = CONF [owise] .
  eq sense(CONF) = CONF [owise] .
  eq enable(CONF) = CONF [owise] .

  eq actuate(((X ||-> V), STATE), 
             store(((L |-> V'), STORE))
             inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
             (X, ACTLIST))
   = ((X ||-> V'), actuate(STATE, store(((L |-> V'), STORE))
             inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
             ACTLIST)) .

  eq actuate(STATE, KC, nilPExpList) = STATE .

  eq sense(store(((L |-> V'), STORE))
           inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
           ((X ||-> V), STATE), (X, SENLIST))
   =  sense(store(((L |-> V), STORE))
           inss(ins(id(PRID) fbtype(PNAME) mem(((X |-> L), MEM)) RESTI) INSS) KC,
           ((X ||-> V), STATE), SENLIST) .

  eq sense(KC, STATE, nilPExpList) = KC .
endm

mod COMMUNICATION is
  including UTIL .
  including EXECUTE .

  sort Channel .
  subsort Channel < NEConfiguration .
  subsort Channel < Cid .
  sorts CMsg CMsgs .
  subsort CMsg < CMsgs .

  op Channel : -> Channel [ctor] .
  op link : Oid Oid -> Oid [ctor comm] .
  op mwrapper : Oid Oid SemanticValue SemanticValue SemanticValue SemanticValue SemanticValue -> CMsg [ctor] .
  --- senderID receiverID sendFBID rcvFBID data minimumDelay
  op emptyBuffer : -> CMsgs [ctor] .
  op __ : CMsgs CMsgs -> CMsgs [ctor assoc comm id: emptyBuffer] .
  op insert : CMsgs CMsg ~> CMsgs .
  op checkMsg : CMsgs Oid PExp PExp ~> Bool .
  op validity :_ : Bool -> Attribute [ctor] .
  op buffer :_ : CMsgs -> Attribute [ctor] .
  op minDelay :_ : PExp -> Attribute [ctor] .
  op maxDelay :_ : PExp -> Attribute [ctor] .

  op minDelay : ~> SemanticValue . 
  op initMinDelay : ~> PExp . 
  op initMaxDelay : ~> PExp . 

  vars O O' : PExp .
  var TARGET : SemanticValue .
  var K : K .
  vars RESTT KC : KConfig .
  vars ATTRS ATTRS' : AttributeSet .
  var BUFFER : CMsgs .
  var NEWM : CMsg .
  vars DATA DATA' SFBID RFBID : SemanticValue .
  var B : Bool .
  vars T D D' MD MD' CONST CONST' : SemanticValue .
  var T2 : Nat .
  vars LOWER UPPER : PExp .

  eq mte(< L:Oid : Channel | ATTRS >, T) = [(true).Boolean] .
  eq envTimeEffect(< L:Oid : Channel | ATTRS >, T:Nat)
   = < L:Oid : Channel | ATTRS > .

  eq insert(BUFFER mwrapper(O, O', SFBID, RFBID, DATA', D', MD'), mwrapper(O, O', SFBID, RFBID, DATA, D, MD))
   = BUFFER mwrapper(O, O', SFBID, RFBID, DATA, D, MD) .
  eq insert(BUFFER, NEWM) = BUFFER NEWM [owise] .
  eq checkMsg(BUFFER mwrapper(O, O', SFBID, RFBID, DATA, D, MD), O, SFBID, RFBID) = true .
  eq checkMsg(BUFFER, O, SFBID, RFBID) = false [owise] .

  op timeEffect : CMsgs SemanticValue ~> CMsgs .

  eq timeEffect(emptyBuffer, T) = emptyBuffer .
  eq timeEffect((mwrapper(O, O', SFBID, RFBID, DATA, D, MD) BUFFER), T)
   = mwrapper(O, O', SFBID, RFBID, DATA, D - T, MD - T) timeEffect(BUFFER, T) .

  eq timeEffect(< link(O, O') : Channel | buffer : BUFFER, ATTRS > CONF:Configuration, T)
   = < link(O, O') : Channel | buffer : timeEffect(BUFFER, T), ATTRS > timeEffect(CONF:Configuration, T) .

  eq timeEffect(CONF:Configuration, T) = CONF:Configuration [owise] .

 ceq [con-succ] :
     < O : PLCMachine | proc : k(connectRequest(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, ATTRS' >
   = < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
  if O' == sem2syn(TARGET) .

 ceq [con-back] :
     < O : PLCMachine | proc : k(connectRequest(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
   = < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
  if O' == sem2syn(TARGET) .

---(
  rl [con-fail] : --- failure, denial, abort 
     < O : PLCMachine | proc : k(connectRequest(O') ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, ATTRS' >
  => < O : PLCMachine | proc : k(K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' > .
---)

 crl [discon-vol]:
     < O : PLCMachine | proc : k(disconnect(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, ATTRS' >
     tickTurn(false)
  => < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, ATTRS' >
     tickTurn(true)
  if O' == sem2syn(TARGET) .


 ceq [isConnected]:
     < O : PLCMachine | proc : k(isConnected(TARGET) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : B, ATTRS' >
   = < O : PLCMachine | proc : k(if B then TRUE else FALSE fi ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : B, ATTRS' >
  if O' == sem2syn(TARGET) .

---(
  rl [discon-unvol] :
     < link(O, O') : Channel | validity : true, ATTRS' >
  => < link(O, O') : Channel | validity : false, ATTRS' > .
---)
 crl [sendData] :
     < O : PLCMachine | proc : k(sendData(TARGET, SFBID, RFBID, DATA) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, minDelay : LOWER, maxDelay : UPPER, ATTRS' >
     tickTurn(false)
  => < O : PLCMachine | proc : k(TRUE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : insert(BUFFER, mwrapper(O, O', SFBID, RFBID, DATA, syn2sem(LOWER), syn2sem(UPPER))), ATTRS' >
     tickTurn(true)
     if O' == sem2syn(TARGET) .

 crl [sendData-fail] :
     < O : PLCMachine | proc : k(sendData(TARGET, SFBID, RFBID, DATA) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
     tickTurn(false)
  => < O : PLCMachine | proc : k(FALSE ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
     tickTurn(true)
     if O' == sem2syn(TARGET) .

 crl [rcvData] :
     < O : PLCMachine | proc : k(rcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : (BUFFER mwrapper(O', O, SFBID, RFBID, DATA, D, MD)), ATTRS' >
     tickTurn(false)
     tconst(CONST)
  => < O : PLCMachine | proc : k(DATA ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' >
     tickTurn(true)
     tconst(CONST AND (D < [(0/1).Real]))
     if O' == sem2syn(TARGET) /\ checkSAT(CONST AND D < [(0/1).Real] AND MD >= [(0/1).Real]) . 

 crl [rcv-fail] :
     < O : PLCMachine | proc : k(rcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
     tickTurn(false)
  => < O : PLCMachine | proc : k(rcvError ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : false, buffer : BUFFER, ATTRS' >
     tickTurn(true)
     if O' == sem2syn(TARGET) .

---(
 crl [wrcvData] :
     < O : PLCMachine | proc : k(wrcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : (BUFFER mwrapper(O', O, SFBID, RFBID, DATA, D)), ATTRS' >
     tickTurn(false)
     tconst(CONST)
  => < O : PLCMachine | proc : k(DATA ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' >
     tickTurn(true)
     tconst(CONST AND D < [(0/1).Real])
     if O' == sem2syn(TARGET) /\ checkSAT(CONST AND D < [(0/1).Real]) .
---)

 crl [rcv-noMsg] :
     < O : PLCMachine | proc : k(rcvData(TARGET, SFBID, RFBID) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' >
     tickTurn(false)
  => < O : PLCMachine | proc : k(rcvError ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, buffer : BUFFER, ATTRS' > 
     tickTurn(true)
  if O' == sem2syn(TARGET) /\ not checkMsg(BUFFER, O', SFBID, RFBID) .

 ceq [assertTime] :
      tconst(CONST)
      < O : PLCMachine | timer : T, proc : k(@assertTime(LOWER, UPPER) ~> K) cycleTime(T2) KC, ATTRS > 
    = tconst(CONST')
      < O : PLCMachine | timer : T, proc : k(K) cycleTime(T2) KC, ATTRS > 
   if CONST' := CONST AND syn2sem(LOWER) <= [T2] - T AND syn2sem(UPPER) >= [T2] - T /\
      checkSAT(CONST') .

  eq [delay] :
     < O : PLCMachine | proc : k(@delay(O, O', LOWER, UPPER) ~> K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, minDelay : A:PExp, maxDelay : B:PExp, ATTRS' >
   = < O : PLCMachine | proc : k(K) KC, ATTRS >
     < link(O, O') : Channel | validity : true, minDelay : LOWER, maxDelay : UPPER , ATTRS' > .

  eq < link(O, O') : Channel | validity : BB:Bool, buffer : BUFFER >
   = < link(O, O') : Channel | validity : BB:Bool, buffer : BUFFER, minDelay : initMinDelay , maxDelay : initMaxDelay > .

  eq initMinDelay = # (1/1) .
  eq initMaxDelay = # (10000/1) .
endm


