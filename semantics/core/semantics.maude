--- basic arithmetic and logical semantics
fmod ALU-SEMANTICS is
  inc CODE-CONFIG .
 
  var SV1 : String .
  var K : K .
  vars T1 T2 : Rat .
  vars ENUMTYPE ENUMVAL : Pid .
  vars V1 V2 : SemanticValue .
  var BITFIELD : Pid .
  var BITINDEX : Nat .

  eq k(# T1  ~> K) = k(syn2sem(# T1) ~> K) .
  eq k(# SV1  ~> K) = k(syn2sem(# SV1) ~> K) .
  eq k(TRUE  ~> K) = k(syn2sem(TRUE) ~> K) .
  eq k(FALSE   ~> K) = k(syn2sem(FALSE) ~> K) .
  eq k(T# T1 ms  ~> K) = k(syn2sem(T# T1 ms) ~> K) .
  eq k(ENUMTYPE # ENUMVAL  ~> K) = k([enumVal(ENUMTYPE, ENUMVAL)] ~> K) .

  ---bitfield
  eq k(V1 . # T1  ~> K) = k(V1 . syn2sem(# T1) ~> K) .
endfm


mod ASSIGNMENT-LOOKUP-SEMANTICS is
  inc CODE-CONFIG .
  inc CONVERSION .
  inc QID .
  inc COMMON-SEMANTIC-VALUE .
  inc CONVERSION-SEMANTICVAL .

  var INSLOC : ProcessId .
  var I : Pid .
  vars V VV : SemanticValue .
  var K : K .
  vars ENV INSENV  : Env .
  var ENVSTACK : ProgramStack .
  vars ARRAYENV ARRAYENV1 ARRAYENV2  : ArrayEnv .
  var STORE : Map{Location, SemanticValue} .
  vars CONST CONST' : SemanticValue .
  var ARRAYINDEX  LOCINDEX : Nat .
  vars RESTINSS INSS : KConfig .
  var LOCATION  : Location .
  vars REST : KConfig .  
  var TYPE : PType .
  var VS : VSet .
  var LOG : Log .
  var RA : Qid .
  var G : Bool .

--- assignment

  op @store : Location SemanticValue -> KLabel [ctor] .
 crl [localAssign] : task(k(@store(LOCATION,V) ~> K) REST) store(STORE) 
  => task(k(K) REST) store(insert(LOCATION, conversion0and1toBOOL(TYPE,V), STORE))
  if loc(LOCINDEX, TYPE, false) := LOCATION /\ $hasMapping(STORE,LOCATION) .

 crl [globalAssign] : task(k(@store(LOCATION,V) ~> K) REST) store(STORE) 
  => task(k(K) REST) store(insert(LOCATION, conversion0and1toBOOL(TYPE,V), STORE))
  if loc(LOCINDEX, TYPE, true) := LOCATION /\ $hasMapping(STORE,LOCATION) .

  eq task(k(I := V ~> K) callStack(ENV :: ENVSTACK) REST)
   = task(k(@store(ENV[I],V) ~> K) callStack(ENV :: ENVSTACK) REST) .


---  eq task(k(InsLoc(INSLOC) . I := V ~> K) REST) inss(INSS) 
---   = task(k(@store(getInsEnv(INSLOC,INSS)[I],V) ~> K) REST) inss(INSS) .

 crl [arrayAssign] : task(k(arrayLoc(ARRAYENV)[VV] := V ~> K) REST) constraints(CONST)
  => task(k(@store(LOCATION,V) ~> K) REST) constraints(simplify(CONST AND CONST'))
  if arrayLookup(ARRAYENV, VV, CONST) => {LOCATION, CONST'} .

--- lookup --- get location
  op @lookup : Location -> KLabel [ctor] .
  eq task(k(@lookup(LOCATION) ~> K) REST) store(STORE) 
   = task(k(STORE[LOCATION] ~> K) REST) store(STORE) .

  --- Pid
  --- global
  rl [lookup] : task(k(I ~> K) callStack(ENV :: ENVSTACK) REST)
  => task(k(@lookup(ENV[I]) ~> K) callStack(ENV :: ENVSTACK) REST) .

 --- _._._._
  eq task(k(InsLoc(INSLOC) . I ~> K)                 REST) inss(INSS) 
   = task(k(@lookup(getInsEnv(INSLOC,INSS)[I]) ~> K) REST) inss(INSS) .

  --- array[V]
 crl [arrayLookup] : task(k(arrayLoc(ARRAYENV)[VV] ~> K) REST) constraints(CONST)
  => task(k(@lookup(LOCATION) ~> K) REST) constraints(simplify(CONST AND CONST'))
  if arrayLookup(ARRAYENV, VV, CONST) => {LOCATION, CONST'} .

 crl [array]: arrayLookup((ARRAYENV1, (ARRAYINDEX, LOCATION), ARRAYENV2), V, CONST) 
           => {LOCATION, (V ==== syn2sem(# ARRAYINDEX))}
  if checkSAT(CONST AND (V ==== syn2sem(# ARRAYINDEX))) .

  eq task(k(botSpace(I) ~> K) 
          callStack(ENVSTACK :: ENV) REST)
   = task(k(@lookup(ENV[I]) ~> K)
          callStack(ENVSTACK :: ENV) REST) . 

  eq task(k(botWrite(I, V) ~> K)
          callStack(ENVSTACK :: ENV) REST)
   = task(k(@store(ENV[I], V) ~> K)
          callStack(ENVSTACK :: ENV) REST) .
endm

--- conditional statement semantics
mod CONDITIONAL-SEMANTICS is 
  inc CODE-CONFIG .
  inc COMMON-SEMANTIC-VALUE .

  vars I : Pid .
  vars V IFSTATEMENT ITECONDITION : SemanticValue .
  vars PV PV1 PV2 : PValue .
  var K : K .
  var BB : BBranch .
  vars S1 S2 : Stmt .
  var CB : CBranch .
  var CONST : SemanticValue .
  vars IFSTATEMENT2 WHILESTATEMENT REPEATSTATEMENT PE1 PE2 : PExp .
  var REST : KConfig .  
  var LOG : Log .
  var RA : Qid .

  --- ite
 crl [iteTrue] : task((k(ite(ITECONDITION, PE1, PE2) ~> K)) REST ) constraints(CONST) 
 => task((k(PE1 ~> K)) REST )  
    constraints(CONST AND (ITECONDITION))
    if checkSAT(CONST AND (ITECONDITION)) .
  
 crl [iteFalse] : task((k(ite(ITECONDITION, PE1, PE2) ~> K)) REST ) constraints(CONST) 
 => task((k(PE2 ~> K)) REST ) 
    constraints(CONST AND (NOT ITECONDITION)) 
    if checkSAT(CONST AND (NOT ITECONDITION)) .

 --- if statement
 crl [IFTRUE] :  
     log(LOG) 
     task(k(IF IFSTATEMENT THEN S1 ; BB ENDIF ~> K) REST ) 
     constraints(CONST)
  => log(LOG (' , 'IFTRUE, placeHolder)) 
     task(k(S1 ~> K) REST) 
     constraints(simplify(CONST AND IFSTATEMENT))
  if checkSAT(CONST AND IFSTATEMENT) .

 crl [IFFALSE] : 
     log(LOG) 
     task(k(IF IFSTATEMENT THEN S1 ; emptyBBranch ENDIF ~> K) REST) 
     constraints(CONST)
  => log(LOG (' , 'IFFALSE, placeHolder)) 
     task(k(K) REST) 
     constraints(simplify(CONST AND (NOT IFSTATEMENT)))
  if checkSAT(CONST AND (NOT IFSTATEMENT)) .

 crl [IFFALSE-ELSIF] : 
     log(LOG) 
     task(k(IF IFSTATEMENT THEN S1 ; ELSIF IFSTATEMENT2 THEN S2 ; BB ENDIF ~> K) REST) 
     constraints(CONST)
  => log(LOG (' , 'IFFALSE-ELSIF, placeHolder)) 
     task(k(IF IFSTATEMENT2 THEN S2 ; BB ENDIF ~> K) REST) 
     constraints(simplify(CONST AND (NOT IFSTATEMENT)))
  if checkSAT(CONST AND (NOT IFSTATEMENT)) .

 crl [IFFALSE-ELSE] : 
     log(LOG)  
     task(k(IF IFSTATEMENT THEN S1 ; ELSE S2 ; ENDIF ~> K) REST) 
     constraints(CONST)
  => log(LOG (' , 'IFFALSE-ELSE, placeHolder)) 
     task(k(S2 ~> K) REST) 
     constraints(simplify(CONST AND (NOT IFSTATEMENT)))
  if checkSAT(CONST AND (NOT IFSTATEMENT)) .


  --- case statement
  eq  task(k(CASE V OF emptyCBranch ELSE S1 ENDCASE ~> K) REST) 
   =  task(k(S1 ~> K) REST)  .

 crl [caseMatch] :  
     log(LOG) 
     task(k(CASE (V)  OF (@ PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST)
  => log(LOG (' , 'caseMatch, V)) 
     task(k(S1 ~> K) REST)  
     constraints(simplify(CONST AND V ==== syn2sem(PV2)))
  if checkSAT(CONST AND V ==== syn2sem(PV2)) .
  

 crl [caseMatchRanged] :  
     task(k(CASE (V)  OF (@ PV1 .. PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST) 
  => task(k(S1 ~> K) REST)   
     constraints(simplify(CONST AND syn2sem(PV1) <= V  AND V <= syn2sem(PV2)))
  if checkSAT(CONST AND syn2sem(PV1) <= V  AND V <= syn2sem(PV2)) .

 crl [caseNotMatch] :  
     task(k(CASE (V)  OF (@ PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST) 
  => task(k(CASE (V)  OF CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(simplify(CONST AND V <> syn2sem(PV2))) 
  if checkSAT(CONST AND V <> syn2sem(PV2)) .

 crl [caseNotMatchRanged] :  
     task(k(CASE (V)  OF (@ PV1 .. PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST) 
  => task(k(CASE (V)  OF CB ELSE S2 ENDCASE ~> K) REST)   
     constraints(simplify(CONST AND (syn2sem(PV1) > V  OR V > syn2sem(PV2))))
  if checkSAT(CONST AND (syn2sem(PV1) > V  OR V > syn2sem(PV2))) .

  --- while statement
  eq task(k(WHILE WHILESTATEMENT DO S1 ENDWHILE ~> K) REST) 
   = task(k(IF WHILESTATEMENT THEN S1 ; WHILE WHILESTATEMENT DO S1 ENDWHILE ; ENDIF ~> K) REST)  .

  --- repeat statement
  eq task(k(REPEAT S1 UNTIL REPEATSTATEMENT ENDREPEAT ~> K) REST) 
   = task(k(IF NOT REPEATSTATEMENT THEN S1 ; REPEAT S1 UNTIL REPEATSTATEMENT ENDREPEAT ; ENDIF ~> K) REST)  .

  --- for statement
  eq task(k(FOR I := V TO PV1 BY PV2 DO S1 ENDFOR ~> K) REST)  
   = task(k(I := V ~> WHILE I <= PV1 DO S1 ; I := I + PV2 ; ENDWHILE ~> K) REST)  .
endm


--- calling of function block, and subprogram
mod CALL-SEMANTICS is
  inc CODE-CONFIG .
  inc COMMON-SEMANTIC-VALUE .

  var CPR : ProcessId .
  vars ENV ENV' INSENV  : Env .
  vars REST RESTINSS INSS : KConfig .  
  var K : K .
  var S : Stmt .
  var ARGS : List{FArgElement} .
  vars STORE STORE' : Map{Location, SemanticValue} .
  var LOCATION : Location .
  vars FBI FBNAME I1 I2 : Pid .
  vars INSLOC ARRAYINDEX : Nat .
  vars V1 V2 CONST CONST' : SemanticValue .
  var RESTENV : ProgramStack .
  var RESTID : List{ProcessId} .
  var PARMETERDATA : VarSecTypePairList .
  vars PARMETERDATA1 PARMETERDATA2 : VarSecTypePairList .
  vars ONEARG PE1 : PExp .
  var P1 : PProperExp  .
  vars ARRAYENV : ArrayEnv .
  var RA : Qid .
  
--- udfb call
  op @call : ProcessId List{FArgElement} -> KLabel [ctor] .
  op @call : ProcessId List{FArgElement} Env Pid -> KLabel [ctor] .
  op @args : List{FArgElement} -> KLabel [ctor] .
  op @bind : Env ProcessId -> KLabel [ctor] .
  op @pop : -> KLabel [ctor] .
  op tag : List{FArgElement} VarSecTypePairList -> List{FArgElement} .

 crl [fbcall] : task(k(FBI(ARGS) ~> K) callStack(ENV :: RESTENV) REST) store(STORE) 
  => task(k(@call(INSLOC,ARGS) ~> K) callStack(ENV :: RESTENV) REST) store(STORE) 
  if InsLoc(INSLOC) := STORE[ENV[FBI]] .

 ceq task(k(@call(INSLOC,ARGS) ~> K) REST) inss(INSS)  
   = task(k(@call(INSLOC,ARGS,INSENV,FBNAME) ~> K) REST) inss(INSS) 
  if INSENV := getInsEnv(INSLOC,INSS)
  /\ FBNAME := getInsType(INSLOC,INSS) .

  eq task(k(@call(INSLOC,ARGS,INSENV,FBNAME) ~> K) REST) 
     PARDef(FBNAME, PARMETERDATA, S) 
   = task(k(@args(tag(ARGS,PARMETERDATA)) ~> @bind(INSENV,INSLOC) ~> S ~> @pop ~> K) REST) 
     PARDef(FBNAME, PARMETERDATA, S) .

  op @ALTERNATIVE : -> PExp [ctor] .
  op INPAR(_) : Pid -> Pid [ctor] .
  op INOUTPAR(_) : Pid -> Pid [ctor] .

  eq tag((ONEARG, ARGS) , ((I1, ##IN)    PARMETERDATA)) = (INPAR(I1)    <:= ONEARG), tag(ARGS, PARMETERDATA) .
  eq tag((ONEARG, ARGS) , ((I1, ##INOUT) PARMETERDATA)) = (INOUTPAR(I1) <:= ONEARG), tag(ARGS, PARMETERDATA) .
  eq tag(nilPExpList, emptyVarSecTypePairList) = nilPExpList .

  eq tag(((I1 <:= ONEARG) , ARGS) , (PARMETERDATA1 (I1, ##IN)    PARMETERDATA2)) = (INPAR(I1)    <:= ONEARG), tag(ARGS, (PARMETERDATA1 PARMETERDATA2)) .
  eq tag(((I1 <:= ONEARG) , ARGS) , (PARMETERDATA1 (I1, ##INOUT) PARMETERDATA2)) = (INOUTPAR(I1) <:= ONEARG), tag(ARGS, (PARMETERDATA1 PARMETERDATA2)) .
  eq tag(nilPExpList, emptyVarSecTypePairList) = nilPExpList .

  --- parameter computation
  --- in parameter
  eq k(@args(((INPAR(I1) <:= P1) , ARGS))  ~> K) = k(P1 ~> @args(((INPAR(I1) <:= @ALTERNATIVE) , ARGS))  ~> K) .
  eq k(V1 ~> @args(((INPAR(I1) <:= @ALTERNATIVE) , ARGS))  ~> K) = k(@args(((INPAR(I1) <:= V1) , ARGS))  ~> K) .

  --- inout parameter
  eq k(@args(((INOUTPAR(I1) <:= P1 . I2) , ARGS))  ~> K) = k(@args(P1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE . I2) , ARGS))  ~> K) .
  eq k(@args(V1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE . I2) , ARGS))  ~> K) = k(@args(((INOUTPAR(I1) <:= V1 . I2) , ARGS))  ~> K) .

  eq k(@args(((INOUTPAR(I1) <:= P1[PE1]) , ARGS))  ~> K) = k(@args(P1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE[PE1]) , ARGS))  ~> K) .
  eq k(@args(V1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE[PE1]) , ARGS))  ~> K) = k(@args(V1 ~> ((INOUTPAR(I1) <:= V1[PE1]) , ARGS))  ~> K) .

  eq k(@args(((INOUTPAR(I1) <:= V1[P1]) , ARGS))  ~> K) = k(@args(P1 ~> ((INOUTPAR(I1) <:= V1[@ALTERNATIVE]) , ARGS))  ~> K) .
  eq k(@args(V2 ~> ((INOUTPAR(I1) <:= V1[@ALTERNATIVE]) , ARGS))  ~> K) = k(@args(((INOUTPAR(I1) <:= V1[V2]) , ARGS))  ~> K) .


  --- parameter binding

  ---in parameter
  eq task(k(@args((INPAR(I1) <:= V1) , ARGS) ~> @bind(ENV,CPR)  ~> K) REST)
   = task(k(@args(ARGS) ~> @bind(ENV,CPR) ~> I1 := V1  ~> K) REST) .

  --- inout parameter
  eq task((k(@args((INOUTPAR(I1) <:= I2) , ARGS) ~> @bind(ENV',CPR)  ~> K)) callStack(ENV :: RESTENV) REST) 
   = task((k(@args(ARGS) ~> @bind(insert(I1, ENV[I2], ENV'),CPR)  ~> K)) callStack(ENV :: RESTENV) REST)  .

  eq task((k(@args((INOUTPAR(I1) <:= InsLoc(INSLOC) . I2) , ARGS) ~> @bind(ENV,CPR)  ~> K)) REST)  inss(INSS)
   = task((k(@args(ARGS) ~> @bind(insert(I1, getInsEnv(INSLOC,INSS)[I2], ENV),CPR)  ~> K)) REST)  inss(INSS) .

 crl [arrayArgBind] : 
     task((k(@args((INOUTPAR(I1) <:= arrayLoc(ARRAYENV)[V2]) , ARGS) ~> @bind(ENV,CPR)  ~> K)) REST)  constraints(CONST) 
  => task((k(@args(ARGS) ~> @bind(insert(I1, LOCATION, ENV),CPR)  ~> K)) REST)  constraints(simplify(CONST AND CONST')) 
  if arrayLookup(ARRAYENV, V2, CONST) => {LOCATION, CONST'} .

  --- context switching
  eq task(k(@args(nilPExpList) ~> @bind(ENV,CPR) ~> K) callStack(RESTENV) REST) 
   = task(k(K) callStack(ENV :: RESTENV) REST)  .

  rl [return] : task((k(@pop ~> K)) callStack(ENV :: RESTENV) REST)  
  => task((k(K)) callStack(RESTENV) REST)   .

  eq task((k(return ~> @pop ~> K)) callStack(ENV :: RESTENV) REST) 
   = task((k(K)) callStack(RESTENV) REST)  . 

  eq task((k(return ~> S ~> K)) REST) 
   = task((k(return ~> K)) REST) . 
endm

fmod STREAM-UPDATE-STREAM-DATA is
  inc CODE-CONFIG .

  vars PNAME I MAIN : Pid .
  var ENV : Env .
  var PE1 : PExp .
  var INSLOC INSLOC2 : ProcessId .
  vars REST RESTINSS : KConfig .  
  var STORE : Map{Location, SemanticValue} .
  var LOCATION : Location .
  vars STREAM STREAM2 : StreamMap .
  vars SEQ  : List{SemanticValue} .
  var VAL : SemanticValue .
  var CYCLENAT : Nat .
  var SV1 : SemanticValue .
  var READYMAINLIST : List{PExp} . 
  vars NOTMAIN1 NOTMAIN2 : List{PExp} .
  var G : Bool .

  op simplifyStore : Map{Location, SemanticValue} -> Map{Location, SemanticValue} .
  eq simplifyStore(((LOCATION |-> SV1), STORE)) = ((LOCATION |-> simplify(SV1)) , simplifyStore(STORE)) .
  eq simplifyStore(empty) = empty .

  op findLocVal : PExp KConfig KConfig ~> SemanticValue .
  
 ceq findLocVal(InsLoc(INSLOC) . I, (ins(id(INSLOC) mem(ENV) REST) RESTINSS), store(STORE)) = InsLoc(INSLOC2)
 if LOCATION := ENV[I] /\ $hasMapping(STORE, LOCATION) /\ InsLoc(INSLOC2) := STORE[LOCATION] .

 ceq findLocVal(InsLoc(INSLOC) . I, (ins(id(INSLOC) mem(ENV) REST) RESTINSS), store(STORE)) = locVal(LOCATION)
 if LOCATION := ENV[I] /\ $hasMapping(STORE, LOCATION) [owise] .

  eq findLocVal(I, (ins(fbtype(I) id(INSLOC) REST) RESTINSS), store(STORE)) = InsLoc(INSLOC) .

  eq findLocVal(PE1 . I, RESTINSS, store(STORE)) = findLocVal(findLocVal(PE1 , RESTINSS, store(STORE)) . I, RESTINSS, store(STORE)) [owise] .

  var LOCN : Nat .
  var LOCTYPE : PType .

  op findLocType : PExp KConfig KConfig ~> PType .
  
  ceq findLocType(InsLoc(INSLOC) . I, (task(id(INSLOC) mem(ENV) REST) RESTINSS), store(STORE)) = LOCTYPE 
  if loc(LOCN, LOCTYPE, G) := ENV[I] .

  eq findLocType(PE1 . I, RESTINSS, store(STORE)) = findLocType(findLocVal(PE1 , RESTINSS, store(STORE)) . I, RESTINSS, store(STORE)) .
endfm

mod STREAM-SEMANTICS is
  inc STREAM-UPDATE-STREAM-DATA .
  inc CODE-CONFIG .

  var VAL : SemanticValue .
  var SVAL : SemanticValue .
  vars STREAM STREAM2 STREAM' INPUTSPECSTREAM INPUTSPECSTREAM' INPUTCOLLECTOR INPUTCOLLECTOR' : StreamMap .
  vars SEQ SEQ' : List{SemanticValue} .
  var KEY : StreamKey .
  var K : K .
  var EXP : PExp .
  var CONST1 CONST2 : SemanticValue .
  vars BOUND BOUND' : Nat .
  vars LTLFORMULA LTLFORMULA' : LTLFormula .
  vars INVARS OUTVARS : SKSet .

  op _{_} : StreamKey Nat -> PProperExp [prec 1] .
  op _|=_ : StreamMap PExp -> [SemanticValue] .
  op eval : PExp StreamMap -> [SemanticValue] .
  op @_|=_ : StreamMap KConfig -> [SemanticValue] .
  op @_|=_ : StreamMap PValue -> [SemanticValue] .

  op refer : List{SemanticValue} Nat -> [SemanticValue] .
  eq refer((VAL, SEQ'), 0) = VAL .
  eq refer((VAL), 0) = VAL .
  eq refer((VAL, SEQ'), (NN:Nat)) = refer(SEQ', (NN:Nat - 1)) .
 ceq refer(VAL, (NN:Nat)) = UNKNOWNOUTPUTVAL if NN:Nat > 0 .
  eq refer(nilSemanticList, NN:Nat) = UNKNOWNOUTPUTVAL .

  eq eval(EXP, STREAM) = STREAM |= EXP .
  eq STREAM |= EXP = @ STREAM |= k(EXP) .

  eq (@ STREAM |= k(UNKNOWNOUTPUTVAL)) = syn2sem(FALSE) .  
  eq (@ STREAM |= k(SVAL)) = SVAL [owise] .  

  eq @ ((KEY |-> SEQ), STREAM') |= k(KEY{NN:Nat} ~> K)
   = @ ((KEY |-> SEQ), STREAM') |= k(refer(SEQ, NN:Nat) ~> K) .
endm

mod STREAM-EXTENSION is
  inc STREAM-SEMANTICS .

  sort TripleTuple .
  op {_,_,_} : LTLFormula FreshVarMap Nat -> TripleTuple [ctor] .

  --- main operators - streams
  op genEmptyStream : SKSet ~> StreamMap .
  op repeat : NeList{StreamValue} -> NeList{StreamValue} [ctor] .
  op symbolic : -> StreamValue [ctor] .
  ops symB symI symR symT : -> StreamValue [ctor] .
  op tail : StreamMap -> [StreamMap] .
  op streamLength : StreamMap -> [Nat] .

  --- key type pair
  sorts KeyTypePair KeyTypePairSet .
  subsort KeyTypePair < KeyTypePairSet .

  op emptyKTPS : -> KeyTypePairSet [ctor] .
  op _is_ : StreamKey PType -> KeyTypePair [ctor] .
  op __ : KeyTypePairSet KeyTypePairSet -> KeyTypePairSet [ctor assoc comm id: emptyKTPS format (d n d)] .
  eq KTP:KeyTypePair KTP:KeyTypePair = KTP:KeyTypePair .
  op genKeyTypePair : StreamMap KConfig ~> KeyTypePair .

  ---(
  =========================================
  ============IMPLEMENTATION===============
  =========================================
  ---)
  vars KEY KEY2 KEY3 : StreamKey .
  vars SEQ SEQ2 SEQ3 : List{StreamValue} .
  vars REALINPUT INPUTSPEC INPUTCOLLECT : List{StreamValue} .
  vars STRMAP STRMAP2 STRMAP3 : StreamMap .
  vars RESTMAP RESTMAP2 : [StreamMap] .
  vars KCF INSS : KConfig .
  vars STORE : Map{Location, SemanticValue} .
  vars N CURR BOUND NEWVARNUM NEWVARNUM1 NEWVARNUM2 SS : Nat .
  vars E E1 E2 E3: StreamValue .
  var FVAR : SemanticValue .
  var FN : Pid .
  var ID : PExp .
  vars COND COND2 OP1 OP2 LEFTFORMULA RIGHTFORMULA : LTLFormula .
  var C : SemanticValue .
  vars FVARMAP1 FVARMAP2 : FreshVarMap .
  var ENV : Env .
  var LOCTYPE : PType .
  var LOCN : Nat . 
  var SKSET : SKSet .
  vars G B : Bool .

  op rename : StreamMap ~> StreamMap .

  eq rename(((FN :: ID  |-> SEQ), RESTMAP)) = ((I[FN :: ID] |-> SEQ), rename(RESTMAP)) .
  eq rename(empty) = empty .

  --- sym variable generation
  op @genSym : StreamKey PType Nat ~> List{StreamValue} .

  op @getType : Pid Env ~> PType .
 ceq @getType(ID, ENV) = LOCTYPE
  if loc(LOCN, LOCTYPE, G) := ENV[ID] . 

  --- streamMap tail
  op @tail : List{StreamValue} ~> List{StreamValue} . 
  eq @tail((SV:StreamValue , SEQ)) = SEQ .
  eq @tail(SV:StreamValue) = nilSemanticList .

  op @size : List{StreamValue} ~> Nat .
  eq @size(nilSemanticList) = 0 .
  eq @size(SV:StreamValue) = 1 .
  eq @size((SV:StreamValue, SEQ)) = 1 + @size(SEQ) .

  eq tail(empty) = empty .
  eq tail((KEY |-> SEQ), RESTMAP) = ((KEY |-> @tail(SEQ)), tail(RESTMAP)) .

  eq streamLength(((KEY |-> SEQ), RESTMAP)) = @size(SEQ) .

  op genFormula : LTLFormula Nat Nat ~> PExp . --- legacy
  op expand : LTLFormula Nat Nat Nat Bool ~> PExp .
---  eq genFormula(LTLF:LTLFormula, CURR, BOUND) = expand(LTLF:LTLFormula, CURR, BOUND) .

  --- base
  eq expand(emptyLTLFormula, CURR, BOUND, SS, B) = emptyLTLFormula .
---  eq expand(FVAR, CURR, BOUND) = FVAR .
  eq expand(KEY{s N}, CURR, BOUND, SS, B) = NEXT(KEY{N}) .
  eq expand(KEY{0}, CURR, BOUND, SS, B) = expand(KEY, CURR, BOUND, SS, B) .
  eq expand(PV:PValue, CURR, BOUND, SS, B) = PV:PValue .
  eq expand(KEY, CURR, BOUND, SS, B) = KEY{CURR} .

  eq expand(OP1 ==== OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) ==== expand(OP2, CURR, BOUND, SS, B) .
  eq expand(OP1 <> OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) <> expand(OP2, CURR, BOUND, SS, B) .
  eq expand(OP1 <> OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) <> expand(OP2, CURR, BOUND, SS, B) .
  eq expand(OP1 < OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) < expand(OP2, CURR, BOUND, SS, B) .
  eq expand(OP1 > OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) > expand(OP2, CURR, BOUND, SS, B) .
  eq expand(OP1 <= OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) <= expand(OP2, CURR, BOUND, SS, B) .
  eq expand(OP1 >= OP2, CURR, BOUND, SS, B) = expand(OP1, CURR, BOUND, SS, B) >= expand(OP2, CURR, BOUND, SS, B) .

  eq expand(NOT COND, CURR, BOUND, SS, B) = (NOT expand(COND, CURR, BOUND, SS, not B)) .
  eq expand(COND AND COND2, CURR, BOUND, SS, B) = expand(COND, CURR, BOUND, SS, B) AND expand(COND2, CURR, BOUND, SS, B) .
  eq expand(COND OR COND2, CURR, BOUND, SS, B) = expand(COND, CURR, BOUND, SS, B) OR expand(COND2, CURR, BOUND, SS, B) .

  --- IMPLICATION
  eq expand(COND ==> COND2, CURR, BOUND, SS, B) 
   = (NOT expand(COND, CURR, BOUND, SS, B)) OR expand(COND2, CURR, BOUND, SS, B) .
  --- NEXT

  eq expand(NEXT(COND), CURR, BOUND, SS, B) 
   = if CURR >= SS then (if B then TRUE else FALSE fi) else (if CURR + 1 >= BOUND then FALSE else expand(COND, CURR + 1, BOUND, SS, B) fi) fi .
  eq expand(WNEXT(COND), CURR, BOUND, SS, B) 
   = if CURR >= SS then (if B then TRUE else FALSE fi) else (if CURR + 1 >= BOUND then  TRUE else expand(COND, CURR + 1, BOUND, SS, B) fi) fi .

 --- FINALLY
  eq expand(FINALLY(COND), CURR, BOUND, SS, B) = expand(COND, CURR, BOUND, SS, B) OR expand(NEXT(FINALLY(COND)), CURR, BOUND, SS, B) .
  --- GLOBALLY
  eq expand(GLOBALLY(COND), CURR, BOUND, SS, B) = expand(COND, CURR, BOUND, SS, B) AND expand(WNEXT(GLOBALLY(COND)), CURR, BOUND, SS, B) .
  --- UNTIL
  eq expand(COND UNTIL COND2, CURR, BOUND, SS, B) = expand(COND2, CURR, BOUND, SS, B) OR (expand(COND, CURR, BOUND, SS, B) AND NEXT(COND UNTIL COND2)) .
endm

--- starting new cycle
mod SCHEDULING-SEMANTICS is
  inc CODE-CONFIG .
  inc STREAM-EXTENSION .

  var TKS : List{ProcessId} .
  vars PRID PRID2 : ProcessId .
  vars PERIOD DUE CYCLECOUNT BOUND NEWVARNUM NEWVARNUM' : Nat .
  vars PR ES DL PR2 ES2 DL2 INTERVAL MINT MAXT N M MAXTIME : Nat .
  var PNAME : Pid .
  var S : Stmt .
  vars CT  : Rat .
  vars KCF PROCS INSS : KConfig .
  vars K K1 K2 : K .
  vars REST REST2 : KConfig . 
  var NEXTINSS : KConfig .
  var PARMETERDATA : VarSecTypePairList .
  var RESTINSS : KConfig .
  vars TNAT CONST CONST' FVAR : SemanticValue .
  var STORE : Map{Location, SemanticValue} .
  vars OUTSTREAM OUTSTREAM' INSTREAM : StreamMap .
  vars REALINPUTSTREAM INPUTSPECSTREAM INPUTCOLLECTSTREAM : StreamMap . 
  vars REALINPUTSTREAM' INPUTSPECSTREAM' INPUTCOLLECTSTREAM' : StreamMap . 
  vars LTLFORMULA LTLFORMULA' : LTLFormula .
  var LTLRESULT LTLRESULT' : checkSATResult .
  vars FVARMAP FVARMAP' FVARMAP'' : FreshVarMap .
  var FVARMAPFORMULA : LTLFormula .
  vars SQ Q1 Q2 : TaskList .
  vars JOBS JS1 JS2 : TaskSet .
  var IM : Map{ProcessId, Nat} .
  vars INVARS OUTVARS : IdSet .
  var VAR : PExp .
  var VARS : List{PExp} .
  var VAL : SemanticValue .
  var SVAL : StreamValue .
  vars SEQ SEQ2 : List{SemanticValue} .
  vars SSEQ SSEQ2 : List{StreamValue} .
  vars STREAM STREAM2 : StreamMap .
  var ENV : Env .
  var LOCN : Nat .
  var LOCTYPE : PType .
  var LOG : Log .
  var ENVSTACK : ProgramStack .
  var TYPE : PType .
  var RA : Qid .
  var AMAP : AdapterMap .
  var SV : StreamVars .

  ops @input @output @timerUpdate : -> KLabel [ctor] .
  ops @takeInput @writeOutput : List{PExp} -> KLabel [ctor] .  
  op getVarList : IdSet ~> List{PExp} .
  eq getVarList(VAR ;;;; INVARS)
   = (VAR, getVarList(INVARS)) . 
  eq getVarList(INVARS) = nilPExpList [owise] .

  eq task(id(PRID) k(@input ~> K) REST)
     streamVars(((PNAME |-> (INVARS, OUTVARS)) , SV))
   = task(id(PRID) k(@takeInput(getVarList(INVARS)) ~> K) REST)
     streamVars(((PNAME |-> (INVARS, OUTVARS)) , SV)) .

  eq task(id(PRID) k(@output ~> K) REST)
     streamVars(((PNAME |-> (INVARS, OUTVARS)) , SV))
   = task(id(PRID) k(@writeOutput(getVarList(OUTVARS)) ~> K) REST)
     streamVars(((PNAME |-> (INVARS, OUTVARS)) , SV)) .

  eq k(@takeInput(nilPExpList) ~> K)
   = k(K) .

  eq k(@writeOutput(nilPExpList) ~> K)
   = k(K) .

  op getType : StreamKey KConfig ~> PType .
  eq getType(PNAME :: VAR, 
             inss(ins(id(PRID) fbtype(PNAME) mem(ENV) REST)INSS) store(STORE) KCF)
   = @getType(VAR, ENV) .

  op annotateType : StreamMap KConfig ~> StreamMap .
  op annotateType : List{StreamValue} PType ~> List{StreamValue} .

  eq annotateType(empty, KCF) = empty .

  eq annotateType(((PNAME :: VAR |-> SSEQ), STREAM), KCF)
   = ((PNAME :: VAR |-> annotateType(SSEQ, getType(PNAME :: VAR, KCF))), annotateType(STREAM, KCF)) .

  eq annotateType((nilStreamList), TYPE) = nilStreamList .
  eq annotateType((VAL), TYPE) = VAL .
  eq annotateType((symbolic), BOOL) = symB .
  eq annotateType((symbolic), REAL) = symR .
  eq annotateType((symbolic), TIME) = symT .
  eq annotateType((symbolic), INT) = symI .
  eq annotateType((symbolic), DINT) = symI .
  eq annotateType((symbolic), SINT) = symI .
  eq annotateType((symbolic), UINT) = symI .
  eq annotateType((symbolic), USINT) = symI .
  eq annotateType((symbolic), UDINT) = symI .

  eq annotateType(repeat(SSEQ), TYPE)
   = repeat(annotateType(SSEQ, TYPE)) .
  eq annotateType(repeat(SSEQ), SSEQ2, TYPE)
   = repeat(annotateType(SSEQ, TYPE)) .

  eq annotateType((SVAL, SSEQ), TYPE)
   = annotateType(SVAL, TYPE), annotateType(SSEQ, TYPE) .

  sorts Range Ranges .
  subsort Range < Ranges .
  var RR : Ranges .

  op empty : -> Ranges [ctor] .
  op __ : Ranges Ranges -> Ranges [ctor assoc comm id: empty] .
  op _|->_ : Pid Nat -> Range [ctor] .


  op streamLength : StreamMap ~> Nat .
  eq streamLength(((PNAME :: VAR |-> SSEQ), STREAM)) = len(SSEQ) .
  
  op adaptedLength : StreamMap AdapterMap ~> Nat .
  eq adaptedLength(STREAM, AMAP) = streamLength(adapt(STREAM, AMAP)) . 
 
  op genRanges : KConfig Nat ~> Ranges .
  eq genRanges(inss(ins(fbtype(PNAME) id(PRID) REST) RESTINSS) 
               interval((PRID |-> INTERVAL, IM))
               futureTS((JS1 @t(PRID, PR, ES, DL))) REST2, MAXTIME)
             = (PNAME |-> ((MAXTIME - ES) quo INTERVAL)) genRanges(
               inss(RESTINSS) REST2
               interval((PRID |-> INTERVAL, IM))
               futureTS((JS1 @t(PRID, PR, ES, DL))), MAXTIME) .

  eq genRanges(REST, MAXTIME) = empty [owise] .

  op srange : Ranges AdapterMap ~> Nat .
  eq srange(((PNAME |-> N) RR), ((PNAME |-> AD:Adapter / M), AMAP))
   = N quo M + (if N rem M > 0 then 1 else 0 fi) .

  op genIS : StreamMap Ranges ~> StreamMap .
  op buildSeq : StreamKey Nat Nat List{StreamValue} ~> List{StreamValue} .
  op repSeq : StreamKey List{StreamValue} Nat Nat ~> List{StreamValue} .

  eq genIS(empty, RR) = empty .

  eq genIS(((PNAME :: VAR |-> SSEQ), STREAM), ((PNAME |-> N) RR))
   = (PNAME :: VAR |-> buildSeq(PNAME :: VAR, 0, N, SSEQ)), genIS(STREAM, RR) .

  eq buildSeq(PNAME :: VAR, N, N, SSEQ) = nilStreamList .

 ceq buildSeq(PNAME :: VAR, M, N, VAL)
   = (VAL, buildSeq(PNAME :: VAR, s M, N, nilStreamList))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, symB)
   = (@genSym(PNAME :: VAR, BOOL, M), buildSeq(PNAME :: VAR, s M, N, nilStreamList))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, symI)
   = (@genSym(PNAME :: VAR, INT, M), buildSeq(PNAME :: VAR, s M, N, nilStreamList))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, symR)
   = (@genSym(PNAME :: VAR, REAL, M), buildSeq(PNAME :: VAR, s M, N, nilStreamList))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, symT)
   = (@genSym(PNAME :: VAR, TIME, M), buildSeq(PNAME :: VAR, s M, N, nilStreamList))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, (VAL, SSEQ))
   = (VAL, buildSeq(PNAME :: VAR, s M, N, SSEQ)) 
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, (symB, SSEQ))
   = (@genSym(PNAME :: VAR, BOOL, M), buildSeq(PNAME :: VAR, s M, N, SSEQ))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, (symI, SSEQ))
   = (@genSym(PNAME :: VAR, INT, M), buildSeq(PNAME :: VAR, s M, N, SSEQ))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, (symR, SSEQ))
   = (@genSym(PNAME :: VAR, REAL, M), buildSeq(PNAME :: VAR, s M, N, SSEQ))
     if M < N .

 ceq buildSeq(PNAME :: VAR, M, N, (symT, SSEQ))
   = (@genSym(PNAME :: VAR, TIME, M), buildSeq(PNAME :: VAR, s M, N, SSEQ))
     if M < N .

  eq buildSeq(PNAME :: VAR, M, N, repeat(SSEQ))
   = repSeq(PNAME :: VAR, SSEQ, M, N) .

  eq repSeq(PNAME :: VAR, SSEQ, N, N) = nilStreamList .

 ceq repSeq(PNAME :: VAR, VAL, M, N)
   = VAL, repSeq(PNAME :: VAR, VAL, s M, N) 
  if M < N .

 ceq repSeq(PNAME :: VAR, symB, M, N)
   = @genSym(PNAME :: VAR, BOOL, M), repSeq(PNAME :: VAR, symB, s M, N) 
  if M < N .

 ceq repSeq(PNAME :: VAR, symI, M, N)
   = @genSym(PNAME :: VAR, INT, M), repSeq(PNAME :: VAR, symI, s M, N) 
  if M < N .
 
 ceq repSeq(PNAME :: VAR, symR, M, N)
   = @genSym(PNAME :: VAR, REAL, M), repSeq(PNAME :: VAR, symR, s M, N) 
  if M < N .

 ceq repSeq(PNAME :: VAR, symT, M, N)
   = @genSym(PNAME :: VAR, TIME, M), repSeq(PNAME :: VAR, symT, s M, N) 
  if M < N .

 ceq repSeq(PNAME :: VAR, (VAL, SSEQ), M, N)
   = VAL, repSeq(PNAME :: VAR, (SSEQ, VAL), s M, N)
  if M < N .
  
 ceq repSeq(PNAME :: VAR, (symB, SSEQ), M, N)
   = @genSym(PNAME :: VAR, BOOL, M), repSeq(PNAME :: VAR, (SSEQ, symB), s M, N)
  if M < N .

 ceq repSeq(PNAME :: VAR, (symI, SSEQ), M, N)
   = @genSym(PNAME :: VAR, INT, M), repSeq(PNAME :: VAR, (SSEQ, symB), s M, N)
  if M < N .

 ceq repSeq(PNAME :: VAR, (symR, SSEQ), M, N)
   = @genSym(PNAME :: VAR, REAL, M), repSeq(PNAME :: VAR, (SSEQ, symB), s M, N)
  if M < N .

 ceq repSeq(PNAME :: VAR, (symT, SSEQ), M, N)
   = @genSym(PNAME :: VAR, TIME, M), repSeq(PNAME :: VAR, (SSEQ, symB), s M, N)
  if M < N .

  eq task(id(PRID) k(@takeInput(VAR, VARS) ~> K) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     inStream((PNAME :: VAR |-> VAL), STREAM)
   = task(id(PRID) k(botWrite(VAR, VAL) ~> @takeInput(VARS) ~> K) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     inStream((PNAME :: VAR |-> nilStreamList), STREAM) .

  eq task(id(PRID) k(@takeInput(VAR, VARS) ~> K) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     inStream((PNAME :: VAR |-> VAL, SEQ), STREAM)
   = task(id(PRID) k(botWrite(VAR, VAL) ~> @takeInput(VARS) ~> K) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     inStream((PNAME :: VAR |-> SEQ), STREAM) .

  eq k(@writeOutput(VAR, VARS) ~> K)
   = k(botSpace(VAR) ~> @writeOutput(VAR, VARS) ~> K) .

  --- output
  eq task(id(PRID) k(VAL ~> @writeOutput(VAR, VARS) ~> K) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     outStream((PNAME :: VAR |-> SEQ), STREAM)
   = task(id(PRID) k(@writeOutput(VARS) ~> K) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     outStream((PNAME :: VAR |-> SEQ, VAL), STREAM) . 

  --- timer update
  eq interval((PRID |-> INTERVAL, IM)) 
     task(id(PRID) k(@timerUpdate ~> K) REST)
     inss(ins(timer(@timer(TNAT)) REST2) RESTINSS)
   = interval((PRID |-> INTERVAL, IM)) 
     task(id(PRID) k(K) REST)
     inss(ins(timer(@timer(TNAT + syn2sem(T# INTERVAL ms))) REST2) RESTINSS) .

  --- is minimum current time necessary?
  rl [schedule] :
     log(LOG) 
     active(None)
     pQueue((@t(PRID, PR, ES, DL), SQ))
     task(id(PRID) k(@block ~> K) REST)
  => log(LOG (getProgramName(PRID), 'schedule, syn2sem(# ES))) 
     active(PRID)
     pQueue((@t(PRID, PR, ES, DL), SQ))
     task(id(PRID) k(K) REST) .

  rl [endProgram] :
     log(LOG) 
     active(PRID)
     task(id(PRID) k(.K) REST)
     pQueue((Q1, @t(PRID, PR, ES, DL), Q2))
     futureTS(JOBS)
     interval((PRID |-> INTERVAL, IM))
     globalTime(MINT, MAXT)
  => log(LOG (getProgramName(PRID), 'endProgram, syn2sem(# ES))) 
     active(None)
     task(id(PRID) k(.K) REST)
     pQueue((Q1, Q2))
     futureTS((JOBS @t(PRID, PR, ES + INTERVAL, DL + INTERVAL)))
     interval((PRID |-> INTERVAL, IM))
     globalTime(maxES((JOBS @t(PRID, PR, ES + INTERVAL, DL + INTERVAL)), (PRID |-> INTERVAL, IM), (Q1, Q2)), 
                minDL((JOBS @t(PRID, PR, ES + INTERVAL, DL + INTERVAL)), (Q1, Q2))) .


  eq [loadNBlock] :
     task(id(PRID) k(@loadNBlock) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     PARDef(PNAME, PARMETERDATA, S)
   = task(id(PRID) k(@block ~> @input ~> @timerUpdate ~> S ~> @output) REST)
     inss(ins(id(PRID) fbtype(PNAME) REST2) INSS)
     PARDef(PNAME, PARMETERDATA, S) .

  op isFirst : TaskList Task ~> Bool .
  eq isFirst((@t(PRID, PR, ES, DL), Q1), @t(PRID, PR, ES, DL)) = true .
  eq isFirst(Q1, @t(PRID, PR, ES, DL)) = false [owise] .

 crl [placeJob-por] :
     log(LOG) 
     globalTime(MINT, MAXT)
     futureTS((@t(PRID, PR, ES, DL) JOBS))
     pQueue(SQ)
     task(id(PRID) k(.K) REST)
  => log(LOG (getProgramName(PRID), 'placeJob, syn2sem(# ES))) 
     globalTime(max(MINT, ES), MAXT)
     futureTS(JOBS)
     pQueue(add(SQ, @t(PRID, PR, ES, DL)))
     task(id(PRID) k(@loadNBlock) REST) 
  if ES < MAXT
  /\ not isFirst(add(SQ, @t(PRID, PR, ES, DL)), @t(PRID, PR, ES, DL)) .


 crl [placeJob] :
     log(LOG) 
     globalTime(MINT, MAXT)
     futureTS((@t(PRID, PR, ES, DL) JOBS))
     pQueue(SQ)
     task(id(PRID) k(.K) REST)
  => log(LOG (getProgramName(PRID), 'placeJob, syn2sem(# ES))) 
     globalTime(max(MINT, ES), MAXT)
     futureTS(JOBS)
     pQueue(add(SQ, @t(PRID, PR, ES, DL)))
     task(id(PRID) k(@loadNBlock) REST) 
  if ES < MAXT
  /\ isFirst(add(SQ, @t(PRID, PR, ES, DL)), @t(PRID, PR, ES, DL)) .

 crl [placeJob-wait-por] :
     log(LOG) 
     globalTime(MINT, MAXT)
     futureTS((@t(PRID, PR, ES, DL) JOBS))
     pQueue(SQ)
     task(id(PRID) k(@block ~> K) REST)
  => log(LOG (getProgramName(PRID), 'placeJob, syn2sem(# ES))) 
     globalTime(max(MINT, ES), MAXT)
     futureTS(JOBS)
     pQueue(add(SQ, @t(PRID, PR, ES, DL)))
     task(id(PRID) k(@block ~> K) REST) 
  if ES < MAXT
  /\ not isFirst(add(SQ, @t(PRID, PR, ES, DL)), @t(PRID, PR, ES, DL)) .

 crl [placeJob-wait] :
     log(LOG) 
     globalTime(MINT, MAXT)
     futureTS((@t(PRID, PR, ES, DL) JOBS))
     pQueue(SQ)
     task(id(PRID) k(@block ~> K) REST)
  => log(LOG (getProgramName(PRID), 'placeJob, syn2sem(# ES)))
     globalTime(max(MINT, ES), MAXT)
     futureTS(JOBS)
     pQueue(add(SQ, @t(PRID, PR, ES, DL)))
     task(id(PRID) k(@block ~> K) REST) 
  if ES < MAXT
  /\ isFirst(add(SQ, @t(PRID, PR, ES, DL)), @t(PRID, PR, ES, DL)) .


  rl [preempt] :
     log(LOG)
     active(PRID2)
     pQueue((@t(PRID, PR, ES, DL), Q1,
             @t(PRID2, PR2, ES2, DL2), Q2))
     task(id(PRID) k(@block ~> K1) REST)
     task(id(PRID2) k(K2) REST2)
  => log(LOG (getProgramName(PRID), 'preempt, syn2sem(# ES)))
     active(PRID)
     pQueue((@t(PRID, PR, ES, DL), Q1,
             @t(PRID2, PR2, ES2, DL2), Q2))
     task(id(PRID) k(K1) REST)
     task(id(PRID2) k(@block ~> K2) REST2) .


  eq log(LOG (getProgramName(PRID), QQ:Qid, SS:SemanticValue) LOG':Log)
     inss(ins(id(PRID) fbtype(PNAME) REST) INSS)
   = log(LOG (PNAME, QQ:Qid, SS:SemanticValue) LOG':Log)
     inss(ins(id(PRID) fbtype(PNAME) REST) INSS) .


 ceq futureTS(JOBS @t(PRID, PR, ES, DL)) maxTime(MAXTIME)
   = futureTS(JOBS) maxTime(MAXTIME)
  if ES >= MAXTIME .


  eq @maxES(emptyJList) = 0 .
  eq @maxES((@t(PRID, PR, ES, DL), SQ)) = max(ES, @maxES(SQ)) .

  eq @maxES(emptyJSet, IM) = 0 .
  eq @maxES((@t(PRID, PR, ES, DL) JOBS), ((PRID |-> INTERVAL), IM))
   = max(ES - INTERVAL, @maxES(JOBS, IM)) .
  eq maxES(JOBS, IM, SQ) = max(0, max(@maxES(SQ), @maxES(JOBS, IM))) .


  eq @minDL(emptyJList) = 1000000 .
  eq @minDL(emptyJSet) = 1000000 .

  eq @minDL((@t(PRID, PR, ES, DL), SQ)) = min(DL, @minDL(SQ)) .
  eq @minDL((@t(PRID, PR, ES, DL) JOBS)) = min(DL, @minDL(JOBS)) .

  eq minDL(JOBS, SQ) = min(@minDL(JOBS), @minDL(SQ)) .

 crl [tick] : 
     log(LOG)
     globalTime(MINT, MAXT)
     pQueue(SQ) futureTS(JOBS) interval(IM) maxTime(M)
  => log(LOG (' , 'tick, placeHolder))
     globalTime(maxES(JOBS, IM, SQ), minDL(SQ, JOBS))
     pQueue(SQ) futureTS(JOBS) interval(IM) maxTime(M)
  if maxES(JOBS, IM, SQ) < M .
endm

--- wait semantics
mod WAIT-SEMANTICS is
  inc CODE-CONFIG .
  inc SCHEDULING-SEMANTICS .
  
  var PRID : ProcessId .
  vars TKS : List{ProcessId} .
  var E : PExp .
  var K : K .
  vars MCT : Rat .
  vars V1 CONST CONST' : SemanticValue .
  vars D P : Nat .
  var REST : KConfig .
  vars PR ES DL IN WT N : Nat .
  var JOBS : TaskSet .
  vars Q1 Q2 : TaskList .
  var IM : Map{ProcessId, Nat} .
  var LOG : Log .

  eq k(WAIT(E) ~> K) = k(IF E THEN skip ; ELSE @release ; WAIT(E) ; ENDIF   ~> K) .

  eq active(PRID)
     pQueue((Q1, @t(PRID, PR, ES, DL), Q2))
     futureTS(JOBS)
     interval((PRID |-> IN, IM))
     task(id(PRID) (k(@release ~> K)) REST)
   = active(None)
     pQueue(Q1, Q2)
     futureTS((JOBS @t(PRID, PR, ES + IN, DL + IN)))
     interval((PRID |-> IN, IM))
     task(id(PRID) (k(@output ~> @block ~> @input ~>  @timerUpdate ~> K)) REST) .
endm

--- semantics for time-related FBs (TON, ...)
fmod TIMER-SEMANTICS is 
  inc CODE-CONFIG .

  vars CPR : ProcessId .
  var IDSTACK : List{ProcessId} .
  var K : K .  
  vars CT PTIME : Rat .
  var PV1 : PValue .
  vars RESTINSS : KConfig .
  vars REST REST2 : KConfig .
  var TVAL : SemanticValue .

  eq task(id(CPR) (k(@#timerValue ~> K)) REST) 
     inss(ins(id(CPR) timer(@timer(TVAL)) REST2) RESTINSS)
   =
     task(id(CPR) (k(TVAL ~> K)) REST) 
     inss(ins(id(CPR) timer(@timer(TVAL)) REST2) RESTINSS) .

  eq task(id(CPR) k(@#timerSetValue(T# PTIME ms) ~> K) REST) 
     inss(ins(id(CPR) timer(@timer(TVAL)) REST2) RESTINSS)
   =
     task(id(CPR) k(K) REST) 
     inss(ins(id(CPR) timer(@timer(syn2sem(T# PTIME ms))) REST2) RESTINSS) .
endfm

