--- basic arithmetic and logical semantics
fmod ALU-SEMANTICS is
  inc CODE-CONFIG .
 
  var SV1 : String .
  var K : K .
  vars T1 T2 : Rat .
  vars ENUMTYPE ENUMVAL : Pid .
  vars V1 V2 : SemanticValue .
  var BITFIELD : Pid .
  var BITINDEX : Nat .

  eq k(# T1  ~> K) = k(syn2sem(# T1) ~> K) .
  eq k(# SV1  ~> K) = k(syn2sem(# SV1) ~> K) .
  eq k(TRUE  ~> K) = k(syn2sem(TRUE) ~> K) .
  eq k(FALSE   ~> K) = k(syn2sem(FALSE) ~> K) .
  eq k(T# T1 ms  ~> K) = k(syn2sem(T# T1 ms) ~> K) .
  eq k(ENUMTYPE # ENUMVAL  ~> K) = k([enumVal(ENUMTYPE, ENUMVAL)] ~> K) .

  ---bitfield
  eq k(V1 . # T1  ~> K) = k(V1 . syn2sem(# T1) ~> K) .
endfm


mod ASSIGNMENT-LOOKUP-SEMANTICS is
  inc CODE-CONFIG .
  inc CONVERSION .
  inc QID .
  inc COMMON-SEMANTIC-VALUE .
  inc CONVERSION-SEMANTICVAL .

  var INSLOC : ProcessId .
  var I : Pid .
  vars V VV : SemanticValue .
  var K : K .
  vars ENV INSENV  : Env .
  var ENVSTACK : ProgramStack .
  vars ARRAYENV ARRAYENV1 ARRAYENV2  : ArrayEnv .
  var STORE : Map{Location, SemanticValue} .
  vars CONST CONST' : SemanticValue .
  var ARRAYINDEX  LOCINDEX : Nat .
  vars RESTINSS INSS : KConfig .
  var LOCATION  : Location .
  vars REST : KConfig .  
  var TYPE : PType .
  var VS : VSet .
  var LOG : Log .
  var RA : Qid .

--- assignment

  op @store : Location SemanticValue -> KLabel [ctor] .
 ceq task(k(@store(LOCATION,V) ~> K) REST) store(STORE) 
   = task(k(K) REST) store(insert(LOCATION, conversion0and1toBOOL(TYPE,V), STORE))
  if loc(LOCINDEX, TYPE) := LOCATION /\ $hasMapping(STORE,LOCATION) .

  --- global
  rl [globalAssign] :
     log(LOG)
     task(k(I := V ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(@(I) VS)
  => log(LOG (I , 'globalAssign, V))
     task(k(@store(ENV[I],V) ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(@(I) VS) .

 crl [localAssign] : task(k(I := V ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(VS)
  => task(k(@store(ENV[I],V) ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(VS)
  if not in(I, VS) .

---  eq task(k(InsLoc(INSLOC) . I := V ~> K) REST) inss(INSS) 
---   = task(k(@store(getInsEnv(INSLOC,INSS)[I],V) ~> K) REST) inss(INSS) .

 crl [arrayAssign] : task(k(arrayLoc(ARRAYENV)[VV] := V ~> K) REST) constraints(CONST)
  => task(k(@store(LOCATION,V) ~> K) REST) constraints(simplify(CONST AND CONST'))
  if arrayLookup(ARRAYENV, VV, CONST) => {LOCATION, CONST'} .

--- lookup --- get location
  op @lookup : Location -> KLabel [ctor] .
  eq task(k(@lookup(LOCATION) ~> K) REST) store(STORE) 
   = task(k(STORE[LOCATION] ~> K) REST) store(STORE) .

  --- Pid
  --- global
  rl [globalLookup] :
     log(LOG) store(STORE)
     task(k(I ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(@(I) VS) 
  => log(LOG (I , 'globalLookUp, placeHolder)) store(STORE)
     task(k(STORE[ENV[I]] ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(@(I) VS) .

  crl [localLookup] : task(k(I ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(VS)
   => task(k(@lookup(ENV[I]) ~> K) callStack(ENV :: ENVSTACK) REST) globalVars(VS)
   if not in(I, VS) .
  --- _._._._
  eq task(k(InsLoc(INSLOC) . I ~> K)                 REST) inss(INSS) 
   = task(k(@lookup(getInsEnv(INSLOC,INSS)[I]) ~> K) REST) inss(INSS) .

  --- array[V]
 crl [arrayLookup] : task(k(arrayLoc(ARRAYENV)[VV] ~> K) REST) constraints(CONST)
  => task(k(@lookup(LOCATION) ~> K) REST) constraints(simplify(CONST AND CONST'))
  if arrayLookup(ARRAYENV, VV, CONST) => {LOCATION, CONST'} .

 crl [array]: arrayLookup((ARRAYENV1, (ARRAYINDEX, LOCATION), ARRAYENV2), V, CONST) 
           => {LOCATION, (V ==== syn2sem(# ARRAYINDEX))}
  if checkSAT(CONST AND (V ==== syn2sem(# ARRAYINDEX))) .
endm

--- conditional statement semantics
mod CONDITIONAL-SEMANTICS is 
  inc CODE-CONFIG .
  inc COMMON-SEMANTIC-VALUE .

  vars I : Pid .
  vars V IFSTATEMENT ITECONDITION : SemanticValue .
  vars PV PV1 PV2 : PValue .
  var K : K .
  var BB : BBranch .
  vars S1 S2 : Stmt .
  var CB : CBranch .
  var CONST : SemanticValue .
  vars IFSTATEMENT2 WHILESTATEMENT REPEATSTATEMENT PE1 PE2 : PExp .
  var REST : KConfig .  
  var LOG : Log .
  var RA : Qid .

  --- ite
 crl [iteTrue] : task((k(ite(ITECONDITION, PE1, PE2) ~> K)) REST ) constraints(CONST) 
 => task((k(PE1 ~> K)) REST )  
    constraints(CONST AND (ITECONDITION))
    if checkSAT(CONST AND (ITECONDITION)) .
  
 crl [iteFalse] : task((k(ite(ITECONDITION, PE1, PE2) ~> K)) REST ) constraints(CONST) 
 => task((k(PE2 ~> K)) REST ) 
    constraints(CONST AND (NOT ITECONDITION)) 
    if checkSAT(CONST AND (NOT ITECONDITION)) .

 --- if statement
 crl [IFTRUE] :  
     log(LOG) 
     task(k(IF IFSTATEMENT THEN S1 ; BB ENDIF ~> K) REST ) 
     constraints(CONST)
  => log(LOG (' , 'IFTRUE, placeHolder)) 
     task(k(S1 ~> K) REST) 
     constraints(simplify(CONST AND IFSTATEMENT))
  if checkSAT(CONST AND IFSTATEMENT) .

 crl [IFFALSE] : 
     log(LOG) 
     task(k(IF IFSTATEMENT THEN S1 ; emptyBBranch ENDIF ~> K) REST) 
     constraints(CONST)
  => log(LOG (' , 'IFFALSE, placeHolder)) 
     task(k(K) REST) 
     constraints(simplify(CONST AND (NOT IFSTATEMENT)))
  if checkSAT(CONST AND (NOT IFSTATEMENT)) .

 crl [IFFALSE-ELSIF] : 
     log(LOG) 
     task(k(IF IFSTATEMENT THEN S1 ; ELSIF IFSTATEMENT2 THEN S2 ; BB ENDIF ~> K) REST) 
     constraints(CONST)
  => log(LOG (' , 'IFFALSE-ELSIF, placeHolder)) 
     task(k(IF IFSTATEMENT2 THEN S2 ; BB ENDIF ~> K) REST) 
     constraints(simplify(CONST AND (NOT IFSTATEMENT)))
  if checkSAT(CONST AND (NOT IFSTATEMENT)) .

 crl [IFFALSE-ELSE] : 
     log(LOG)  
     task(k(IF IFSTATEMENT THEN S1 ; ELSE S2 ; ENDIF ~> K) REST) 
     constraints(CONST)
  => log(LOG (' , 'IFFALSE-ELSE, placeHolder)) 
     task(k(S2 ~> K) REST) 
     constraints(simplify(CONST AND (NOT IFSTATEMENT)))
  if checkSAT(CONST AND (NOT IFSTATEMENT)) .


  --- case statement
  eq  task(k(CASE V OF emptyCBranch ELSE S1 ENDCASE ~> K) REST) 
   =  task(k(S1 ~> K) REST)  .

 crl [caseMatch] :  
     log(LOG) 
     task(k(CASE (V)  OF (@ PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST)
  => log(LOG (' , 'caseMatch, V)) 
     task(k(S1 ~> K) REST)  
     constraints(simplify(CONST AND V ==== syn2sem(PV2)))
  if checkSAT(CONST AND V ==== syn2sem(PV2)) .
  

 crl [caseMatchRanged] :  
     task(k(CASE (V)  OF (@ PV1 .. PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST) 
  => task(k(S1 ~> K) REST)   
     constraints(simplify(CONST AND syn2sem(PV1) <= V  AND V <= syn2sem(PV2)))
  if checkSAT(CONST AND syn2sem(PV1) <= V  AND V <= syn2sem(PV2)) .

 crl [caseNotMatch] :  
     task(k(CASE (V)  OF (@ PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST) 
  => task(k(CASE (V)  OF CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(simplify(CONST AND V <> syn2sem(PV2))) 
  if checkSAT(CONST AND V <> syn2sem(PV2)) .

 crl [caseNotMatchRanged] :  
     task(k(CASE (V)  OF (@ PV1 .. PV2 : S1) CB ELSE S2 ENDCASE ~> K) REST)  
     constraints(CONST) 
  => task(k(CASE (V)  OF CB ELSE S2 ENDCASE ~> K) REST)   
     constraints(simplify(CONST AND (syn2sem(PV1) > V  OR V > syn2sem(PV2))))
  if checkSAT(CONST AND (syn2sem(PV1) > V  OR V > syn2sem(PV2))) .

  --- while statement
  eq task(k(WHILE WHILESTATEMENT DO S1 ENDWHILE ~> K) REST) 
   = task(k(IF WHILESTATEMENT THEN S1 ; WHILE WHILESTATEMENT DO S1 ENDWHILE ; ENDIF ~> K) REST)  .

  --- repeat statement
  eq task(k(REPEAT S1 UNTIL REPEATSTATEMENT ENDREPEAT ~> K) REST) 
   = task(k(IF NOT REPEATSTATEMENT THEN S1 ; REPEAT S1 UNTIL REPEATSTATEMENT ENDREPEAT ; ENDIF ~> K) REST)  .

  --- for statement
  eq task(k(FOR I := V TO PV1 BY PV2 DO S1 ENDFOR ~> K) REST)  
   = task(k(I := V ~> WHILE I <= PV1 DO S1 ; I := I + PV2 ; ENDWHILE ~> K) REST)  .
endm


--- calling of function block, and subprogram
mod CALL-SEMANTICS is
  inc CODE-CONFIG .
  inc COMMON-SEMANTIC-VALUE .

  var CPR : ProcessId .
  vars ENV ENV' INSENV  : Env .
  vars REST RESTINSS INSS : KConfig .  
  var K : K .
  var S : Stmt .
  var ARGS : List{FArgElement} .
  vars STORE STORE' : Map{Location, SemanticValue} .
  var LOCATION : Location .
  vars FBI FBNAME I1 I2 : Pid .
  vars INSLOC ARRAYINDEX : Nat .
  vars V1 V2 CONST CONST' : SemanticValue .
  var RESTENV : ProgramStack .
  var RESTID : List{ProcessId} .
  var PARMETERDATA : VarSecTypePairList .
  vars PARMETERDATA1 PARMETERDATA2 : VarSecTypePairList .
  vars ONEARG PE1 : PExp .
  var P1 : PProperExp  .
  vars ARRAYENV : ArrayEnv .
  var RA : Qid .
  
--- udfb call
  op @call : ProcessId List{FArgElement} -> KLabel [ctor] .
  op @call : ProcessId List{FArgElement} Env Pid -> KLabel [ctor] .
  op @args : List{FArgElement} -> KLabel [ctor] .
  op @bind : Env ProcessId -> KLabel [ctor] .
  op @pop : -> KLabel [ctor] .
  op tag : List{FArgElement} VarSecTypePairList -> List{FArgElement} .

 crl [fbcall] : task(k(FBI(ARGS) ~> K) callStack(ENV :: RESTENV) REST) store(STORE) 
  => task(k(@call(INSLOC,ARGS) ~> K) callStack(ENV :: RESTENV) REST) store(STORE) 
  if InsLoc(INSLOC) := STORE[ENV[FBI]] .

 ceq task(k(@call(INSLOC,ARGS) ~> K) REST) inss(INSS)  
   = task(k(@call(INSLOC,ARGS,INSENV,FBNAME) ~> K) REST) inss(INSS) 
  if INSENV := getInsEnv(INSLOC,INSS)
  /\ FBNAME := getInsType(INSLOC,INSS) .

  eq task(k(@call(INSLOC,ARGS,INSENV,FBNAME) ~> K) REST) 
     PARDef(FBNAME, PARMETERDATA, S) 
   = task(k(@args(tag(ARGS,PARMETERDATA)) ~> @bind(INSENV,INSLOC) ~> S ~> @pop ~> K) REST) 
     PARDef(FBNAME, PARMETERDATA, S) .

  op @ALTERNATIVE : -> PExp [ctor] .
  op INPAR(_) : Pid -> Pid [ctor] .
  op INOUTPAR(_) : Pid -> Pid [ctor] .

  eq tag((ONEARG, ARGS) , ((I1, ##IN)    PARMETERDATA)) = (INPAR(I1)    <:= ONEARG), tag(ARGS, PARMETERDATA) .
  eq tag((ONEARG, ARGS) , ((I1, ##INOUT) PARMETERDATA)) = (INOUTPAR(I1) <:= ONEARG), tag(ARGS, PARMETERDATA) .
  eq tag(nilPExpList, emptyVarSecTypePairList) = nilPExpList .

  eq tag(((I1 <:= ONEARG) , ARGS) , (PARMETERDATA1 (I1, ##IN)    PARMETERDATA2)) = (INPAR(I1)    <:= ONEARG), tag(ARGS, (PARMETERDATA1 PARMETERDATA2)) .
  eq tag(((I1 <:= ONEARG) , ARGS) , (PARMETERDATA1 (I1, ##INOUT) PARMETERDATA2)) = (INOUTPAR(I1) <:= ONEARG), tag(ARGS, (PARMETERDATA1 PARMETERDATA2)) .
  eq tag(nilPExpList, emptyVarSecTypePairList) = nilPExpList .

  --- parameter computation
  --- in parameter
  eq k(@args(((INPAR(I1) <:= P1) , ARGS))  ~> K) = k(P1 ~> @args(((INPAR(I1) <:= @ALTERNATIVE) , ARGS))  ~> K) .
  eq k(V1 ~> @args(((INPAR(I1) <:= @ALTERNATIVE) , ARGS))  ~> K) = k(@args(((INPAR(I1) <:= V1) , ARGS))  ~> K) .

  --- inout parameter
  eq k(@args(((INOUTPAR(I1) <:= P1 . I2) , ARGS))  ~> K) = k(@args(P1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE . I2) , ARGS))  ~> K) .
  eq k(@args(V1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE . I2) , ARGS))  ~> K) = k(@args(((INOUTPAR(I1) <:= V1 . I2) , ARGS))  ~> K) .

  eq k(@args(((INOUTPAR(I1) <:= P1[PE1]) , ARGS))  ~> K) = k(@args(P1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE[PE1]) , ARGS))  ~> K) .
  eq k(@args(V1 ~> ((INOUTPAR(I1) <:= @ALTERNATIVE[PE1]) , ARGS))  ~> K) = k(@args(V1 ~> ((INOUTPAR(I1) <:= V1[PE1]) , ARGS))  ~> K) .

  eq k(@args(((INOUTPAR(I1) <:= V1[P1]) , ARGS))  ~> K) = k(@args(P1 ~> ((INOUTPAR(I1) <:= V1[@ALTERNATIVE]) , ARGS))  ~> K) .
  eq k(@args(V2 ~> ((INOUTPAR(I1) <:= V1[@ALTERNATIVE]) , ARGS))  ~> K) = k(@args(((INOUTPAR(I1) <:= V1[V2]) , ARGS))  ~> K) .


  --- parameter binding

  ---in parameter
  eq task(k(@args((INPAR(I1) <:= V1) , ARGS) ~> @bind(ENV,CPR)  ~> K) REST)
   = task(k(@args(ARGS) ~> @bind(ENV,CPR) ~> I1 := V1  ~> K) REST) .

  --- inout parameter
  eq task((k(@args((INOUTPAR(I1) <:= I2) , ARGS) ~> @bind(ENV',CPR)  ~> K)) callStack(ENV :: RESTENV) REST) 
   = task((k(@args(ARGS) ~> @bind(insert(I1, ENV[I2], ENV'),CPR)  ~> K)) callStack(ENV :: RESTENV) REST)  .

  eq task((k(@args((INOUTPAR(I1) <:= InsLoc(INSLOC) . I2) , ARGS) ~> @bind(ENV,CPR)  ~> K)) REST)  inss(INSS)
   = task((k(@args(ARGS) ~> @bind(insert(I1, getInsEnv(INSLOC,INSS)[I2], ENV),CPR)  ~> K)) REST)  inss(INSS) .

 crl [arrayArgBind] : 
     task((k(@args((INOUTPAR(I1) <:= arrayLoc(ARRAYENV)[V2]) , ARGS) ~> @bind(ENV,CPR)  ~> K)) REST)  constraints(CONST) 
  => task((k(@args(ARGS) ~> @bind(insert(I1, LOCATION, ENV),CPR)  ~> K)) REST)  constraints(simplify(CONST AND CONST')) 
  if arrayLookup(ARRAYENV, V2, CONST) => {LOCATION, CONST'} .

  --- context switching
  eq task(k(@args(nilPExpList) ~> @bind(ENV,CPR) ~> K) callStack(RESTENV) REST) 
   = task(k(K) callStack(ENV :: RESTENV) REST)  .

  rl [return] : task((k(@pop ~> K)) callStack(ENV :: RESTENV) REST)  
  => task((k(K)) callStack(RESTENV) REST)   .

  eq task((k(return ~> @pop ~> K)) callStack(ENV :: RESTENV) REST) 
   = task((k(K)) callStack(RESTENV) REST)  . 

  eq task((k(return ~> S ~> K)) REST) 
   = task((k(return ~> K)) REST) . 
endm

--- starting new cycle
mod CYCLE-SEMANTICS is
  inc CALL-SEMANTICS .

  op @end : -> K [ctor] .
  op timerUpdate : Rat KConfig ~> KConfig .

  vars REST RESTINS RESTINSS KCF : KConfig .
  var PNAME : Pid .
  var PARAM : VarSecTypePairList .
  var S : Stmt . 
  var CT : Nat .
  var ENV : Env .
  var PRID : ProcessId .  
  var TNAT : SemanticValue .

  eq timerUpdate(CT, empty) = empty .
  eq timerUpdate(CT, (ins(timer(@timer(TNAT)) REST) KCF)) 
  = ins(timer(@timer(simplify(TNAT + syn2sem(T# CT ms)))) REST) timerUpdate(CT,  KCF) .

  eq [endProgram] :
     task(k(.K) REST) = [task(k(@end) REST)] .

  rl [scExec] :
     task(k(@end) id(PRID) REST)
     inss(ins(id(PRID) fbtype(PNAME) mem(ENV) RESTINS) RESTINSS)
     PARDef(PNAME, PARAM, S)
     cycleTime(CT)
  => task(k(@call(PRID, nilPExpList, ENV, PNAME)) REST) 
     inss(timerUpdate(CT, ins(id(PRID) fbtype(PNAME) mem(ENV) RESTINS) RESTINSS))
     PARDef(PNAME, PARAM, S)
     cycleTime(CT) .
endm

--- semantics for time-related FBs (TON, ...)
fmod TIMER-SEMANTICS is 
  inc CODE-CONFIG .

  vars CPR : ProcessId .
  var IDSTACK : List{ProcessId} .
  var K : K .  
  vars CT PTIME : Rat .
  var PV1 : PValue .
  vars RESTINSS : KConfig .
  vars REST REST2 : KConfig .
  var TVAL : SemanticValue .

  eq task(id(CPR) (k(@#timerValue ~> K)) REST) 
     inss(ins(id(CPR) timer(@timer(TVAL)) REST2) RESTINSS)
   =
     task(id(CPR) (k(TVAL ~> K)) REST) 
     inss(ins(id(CPR) timer(@timer(TVAL)) REST2) RESTINSS) .

  eq task(id(CPR) k(@#timerSetValue(T# PTIME ms) ~> K) REST) 
     inss(ins(id(CPR) timer(@timer(TVAL)) REST2) RESTINSS)
   =
     task(id(CPR) k(K) REST) 
     inss(ins(id(CPR) timer(@timer(syn2sem(T# PTIME ms))) REST2) RESTINSS) .
endfm

