fmod JOBS is
  inc PROCESS-ID .

  sort Task .
  op @t : ProcessId Nat Nat Nat -> Task [ctor] .
       --- (processId, priority, interval, earliest starting time, deadline)
  sort TaskSet .
  subsort Task < TaskSet .
  op emptyJSet : -> TaskSet [ctor] .
  op __ : TaskSet TaskSet -> TaskSet [ctor assoc comm id: emptyJSet] . 

  sort TaskList .
  subsort Task < TaskList .
  op emptyJList : -> TaskList [ctor] .
  op _,_ : TaskList TaskList -> TaskList [ctor assoc id: emptyJList] .

  op add : TaskList Task ~> TaskList .

  vars TID1 TID2 : ProcessId .
  vars PR1 PR2 ES1 ES2 DL1 DL2 : Nat .
  var JL : TaskList .
  var JS : TaskSet .
  eq add(emptyJList, J:Task) = J:Task .
 ceq add((@t(TID1, PR1, ES1, DL1), JL), @t(TID2, PR2, ES2, DL2))
   = (@t(TID2, PR2, ES2, DL2), @t(TID1, PR1, ES1, DL1), JL)
  if DL2 <= ES1 . 
 ceq add((@t(TID1, PR1, ES1, DL1), JL), @t(TID2, PR2, ES2, DL2))
   = (@t(TID1, PR1, ES1, DL1), add(JL, @t(TID2, PR2, ES2, DL2)))
  if DL1 <= ES2 . 

  eq add((@t(TID1, PR1, ES1, DL1), JL), @t(TID2, PR2, ES2, DL2))
   = if PR1 <= PR2 then
       (@t(TID1, PR1, ES1, DL1), add(JL, @t(TID2, PR2, ES2, DL2)))
     else
       (@t(TID2, PR2, ES2, DL2), @t(TID1, PR1, ES1, DL1), JL)
     fi [owise] .

  op earlist : Task TaskSet ~> Bool .

 ceq earlist(@t(TID1, PR1, ES1, DL1), (@t(TID2, PR2, ES2, DL2) JS)) = false
  if ES1 > ES2 or (ES1 == ES2 and PR1 > PR2) .

  eq earlist(@t(TID1, PR1, ES1, DL1), JS) = true [owise] .

  sort TaskOption .
  op Some : Task -> TaskOption [ctor] .
  op None : -> TaskOption [ctor] .
endfm

fmod STREAM is
  inc BASIC-PEXP .
  inc PLC-EXP-LIST .
  inc SEMANTIC-LIST .

  sort StreamKey .
  op _::_ : Pid PExp -> StreamKey [ctor prec 0] .   
  op I[_::_] : Pid PExp -> StreamKey [ctor prec 0] .              
  subsort StreamKey < PExp .
  op _{_} : StreamKey Nat -> PExp [prec 1] .

  sorts StreamMapEntry StreamMap .
  subsort StreamMapEntry < StreamMap .
  op empty : -> StreamMap [ctor] .
  op _,_ : StreamMap StreamMap -> StreamMap [ctor assoc comm id: empty] .   
  op _|->_ : StreamKey List{StreamValue} -> StreamMapEntry [ctor] . 

  op minSize : StreamMap ~> Nat .

  sorts KeySet .

  sort IdSet .
  subsort PExp < IdSet .
  op emptyIdSet : -> IdSet [ctor] .
  op _;;;;_ : IdSet IdSet -> IdSet [ctor assoc comm id: emptyIdSet] .

  sorts StreamVars StreamVarsEntry .
  subsort StreamVarsEntry < StreamVars .
  op emptySV : -> StreamVars [ctor] .
  op _,_ : StreamVars StreamVars -> StreamVars [ctor assoc comm id: emptySV] .
  op _|->(_,_) : Pid IdSet IdSet -> StreamVarsEntry [ctor] .   


  sort SKSet .
  subsort StreamKey < SKSet . 
  op emptySKSet : -> SKSet [ctor] .
  op _;;;;;_ : SKSet SKSet -> SKSet [ctor assoc comm id: emptySKSet] .
  op setDiff : SKSet SKSet ~> SKSet .
  op streamKeySet : StreamMap ~> SKSet .
  op genEmptyStream : SKSet ~> StreamMap .

  vars SKS1 SKS2 : SKSet .
  var KEY : StreamKey .
  var SEQ : List{StreamValue} .
  var RESTMAP : StreamMap .

  eq KEY ;;;;; KEY = KEY .

  eq minSize(KEY |-> SEQ) = len(SEQ) .
  eq minSize((KEY |-> SEQ), RESTMAP) = min(len(SEQ), minSize(RESTMAP)) .

  eq setDiff(SKS1, emptySKSet) = SKS1 .
  eq setDiff((KEY ;;;;; SKS1), (KEY ;;;;; SKS2)) = setDiff(SKS1, SKS2) .
  eq setDiff(SKS1, (KEY ;;;;; SKS2)) = setDiff(SKS1, SKS2) [owise] .

  eq streamKeySet(empty) = emptySKSet .
  eq streamKeySet((KEY |-> SEQ), RESTMAP) = (KEY ;;;;; streamKeySet(RESTMAP)) . 

  eq genEmptyStream(emptySKSet) = empty .
  eq genEmptyStream((KEY ;;;;; SKS1)) = ((KEY |-> nilSemanticList), genEmptyStream(SKS1)) .

  var PNAME : Pid .
  var VAR : PExp .
  var SV : StreamVars .
  vars IDSET IDSET2 : IdSet .

  op composeSV : SKSet SKSet ~> StreamVars .
  eq composeSV(SKS1, SKS2) = composeSV(SKS1, SKS2, emptySV) .

  op composeSV : SKSet SKSet StreamVars ~> StreamVars .
  eq composeSV(emptySKSet, emptySKSet, SV) = SV . 

  eq composeSV((PNAME :: VAR ;;;;; SKS1), SKS2, SV)
   = composeSV(SKS1, SKS2, ((PNAME |-> (VAR, emptyIdSet)), SV)) [owise] .
  eq composeSV((PNAME :: VAR ;;;;; SKS1), SKS2, ((PNAME |-> (IDSET, IDSET2)), SV))
   = composeSV(SKS1, SKS2, ((PNAME |-> ((IDSET ;;;; VAR), IDSET2)), SV)) .
  eq composeSV(emptySKSet, (PNAME :: VAR ;;;;; SKS2), SV)
   = composeSV(emptySKSet, SKS2, ((PNAME |-> (emptyIdSet, VAR)), SV)) [owise] .
  eq composeSV(emptySKSet, (PNAME :: VAR ;;;;; SKS2), ((PNAME |-> (IDSET, IDSET2)), SV))
   = composeSV(emptySKSet, SKS2, ((PNAME |-> (IDSET, (IDSET2 ;;;; VAR))), SV)) .

  --- adapter
  sort Adapter .
  ops min max first last : -> Adapter [ctor] . 

  sorts AdapterMap AdapterMapEntry .
  subsort AdapterMapEntry < AdapterMap .
  op emptyAMap : -> AdapterMap [ctor] .
  op _|->_/_ : Pid Adapter Nat -> AdapterMapEntry [ctor] .
  op _,_ : AdapterMap AdapterMap -> AdapterMap [ctor assoc comm id: emptyAMap] .

  op adapt : StreamMap AdapterMap ~> StreamMap . 
  op adaptSeq : List{StreamValue} Adapter Nat ~> List{StreamValue} .
  op take : List{StreamValue} Nat ~> List{StreamValue} .
  op pick : List{StreamValue} Adapter ~> StreamValue .
  op erase : List{StreamValue} Nat ~> List{StreamValue} .

  op cutSize : StreamMap AdapterMap ~> Nat .

  var P : Pid .
  var V : PExp .
  var N : Nat .
  var AM : AdapterMap . 
  var AD : Adapter .
  var HEAD : StreamValue .
  eq adapt(empty, AM) = empty .
  eq adapt(((P :: V |-> SEQ), RESTMAP), ((P |-> AD / N), AM))
   = (P :: V |-> adaptSeq(SEQ, AD, N)), adapt(RESTMAP, ((P |-> AD / N), AM)) .
  eq adapt(((I[P :: V] |-> SEQ), RESTMAP), ((P |-> AD / N), AM))
   = (I[P :: V] |-> adaptSeq(SEQ, AD, N)), adapt(RESTMAP, ((P |-> AD / N), AM)) .

  eq erase(nilStreamList, N) = nilStreamList .
  eq erase(HEAD, s N) = nilStreamList .
  eq erase(SEQ, 0) = SEQ .
  eq erase((HEAD, SEQ), s N) = erase(SEQ, N) .

  eq adaptSeq(SEQ, AD, N) = pick(take(SEQ, N), AD), adaptSeq(erase(SEQ, N), AD, N) [owise] . 
  eq adaptSeq(nilStreamList, AD, N) = nilStreamList .

  eq take(SEQ, 0) = nilStreamList .
  eq take(HEAD, 1) = HEAD .
---  eq take(nilStreamList, s N) = nilStreamList .
  eq take((HEAD, SEQ), s N) = HEAD, take(SEQ, N) .

  eq pick(HEAD, AD) = HEAD .
  eq pick((HEAD, SEQ), first) = HEAD .
  eq pick((SEQ, HEAD), last) = HEAD .

  --- min ???
  --- max ???

  eq cutSize(((P :: V |-> SEQ), RESTMAP), ((P |-> AD / N), AM))
   = len(SEQ) / N .
endfm

fmod LTLFORMULA is
  inc STREAM .

  sort LTLFormula .
  subsort PExp < LTLFormula .

  op emptyLTLFormula : -> LTLFormula [ctor] .

  op NOT_ : LTLFormula -> LTLFormula [ditto] .
  ops _AND_ _OR_ : LTLFormula LTLFormula -> LTLFormula [ditto] .
  ops _====_ _<>_ _<>_ _>_ _<_ _>=_ _<=_ : LTLFormula LTLFormula -> LTLFormula [ditto] .

  ops FINALLY GLOBALLY NEXT WNEXT : LTLFormula -> LTLFormula [ctor] .
  ops _UNTIL_ _==>_ : LTLFormula LTLFormula -> LTLFormula [ctor] .

  sorts FreshVarMapEntry FreshVarMap .
  subsort FreshVarMapEntry < FreshVarMap .
  op emptyFreshVarMap : -> FreshVarMap [ctor] .
  op _,_ : FreshVarMap FreshVarMap -> FreshVarMap [ctor assoc comm id: emptyFreshVarMap] .   
  op _<-|_ : SemanticValue LTLFormula -> FreshVarMapEntry [ctor] . 

  op collectKeySet : LTLFormula ~> SKSet .

  vars COND COND2 OP1 OP2 : LTLFormula .
  var KEY : StreamKey .
  var N : Nat .

  eq collectKeySet(GLOBALLY(COND)) = collectKeySet(COND) .
  eq collectKeySet(FINALLY(COND)) = collectKeySet(COND) .
  eq collectKeySet(NEXT(COND)) = collectKeySet(COND) .
  eq collectKeySet(WNEXT(COND)) = collectKeySet(COND) .

  eq collectKeySet(NOT COND) = collectKeySet(COND) .
  eq collectKeySet(COND AND COND2) = ((collectKeySet(COND) ;;;;; collectKeySet(COND2))) .
  eq collectKeySet(COND OR COND2) = ((collectKeySet(COND) ;;;;; collectKeySet(COND2))) .
  eq collectKeySet(COND ==> COND2) = ((collectKeySet(COND) ;;;;; collectKeySet(COND2))) .
  eq collectKeySet(COND UNTIL COND2) = ((collectKeySet(COND) ;;;;; collectKeySet(COND2))) .
  eq collectKeySet(OP1 > OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(OP1 >= OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(OP1 < OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(OP1 <= OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(OP1 ==== OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(OP1 <> OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(OP1 <> OP2) = collectKeySet(OP1) ;;;;; collectKeySet(OP2) . 
  eq collectKeySet(KEY{N}) = KEY . --- concrete base case
  eq collectKeySet(KEY) = KEY . --- symbolic base case
  eq collectKeySet(OP1) = emptySKSet [owise] .
endfm

fmod PROGRAMSTACK is
  inc ENV .
  inc PROCESS-ID .
  sort ProgramStack .

  subsort Env < ProgramStack .
  op nilProgramStack : -> ProgramStack [ctor] .
  op _::_ : ProgramStack ProgramStack -> ProgramStack [assoc id: nilProgramStack] .
endfm

fmod VARPARMETERTYPE is
  inc VAR-DECLARATION-SYNTAX .
  sort VarSecTypePair .
  sort VarSecTypePairList .
  subsort VarSecTypePair < VarSecTypePairList .

  op (_,_) : Pid VarSectionType ->  VarSecTypePair [ctor] .

  op emptyVarSecTypePairList : -> VarSecTypePairList [ctor] .
  op __ : VarSecTypePairList VarSecTypePairList -> VarSecTypePairList [assoc id: emptyVarSecTypePairList] .
endfm

fmod VSET is
  inc PID .

  sort VSet .
  op @ : Pid -> VSet [ctor] .
  op emptyVSet : -> VSet [ctor] .
  op __ : VSet VSet -> VSet [ctor assoc comm id: emptyVSet] .
  op in : Pid VSet ~> Bool .

  var VS : VSet .
  var I : Pid .
  eq in(I, @(I) VS) = true .
  eq in(I, VS) = false [owise] .
endfm

fmod TIMER is
  inc COMMON-SEMANTIC-VALUE .
  inc PLC-STRICTNESS-RULES .

  sort Timer .
  op @timer : SemanticValue -> Timer [ctor] .
endfm

fmod COMPONENT is
  inc TIMER .
  inc PROCESS-ID .
  inc K-CONFIG .
  inc PROGRAMSTACK .
  inc ENV .
  inc LIST{ProcessId} * (op __ to _::_, 
op nil to nilProcIds,
op append to appendx,
op head to headx,
op tail to tailx,
op last to lastx,
op front to frontx,
op occurs to occursx,
op reverse to reversex,
op $reverse to $reversex,
op size to sizex,
op $size to $sizex
) .
  inc VARPARMETERTYPE .

  op id : ProcessId -> KConfig [ctor] .
  op fbtype : Pid -> KConfig [ctor] .
  op timer : Timer -> KConfig [ctor] .
  op mem : Env -> KConfig [ctor] .
  op callStack : ProgramStack -> KConfig [ctor] .
endfm

fmod LOG is
  inc COMMON-SEMANTIC-VALUE .
  inc PID . 

  sorts Log LogEntry .
  subsort LogEntry < Log .
  op emptyLog : -> LogEntry [ctor format(u o)] .
  op __ : Log Log -> Log [ctor assoc id: emptyLog prec 1] .
  op _,_,_ : Pid Qid SemanticValue -> LogEntry [ctor prec 0 format(u u u u u on)] .

  op getProgramName : ProcessId ~> Pid .
endfm

--- CODE-CONFIG defines K Configuration (cell structure)  
fmod CODE-CONFIG is
  inc TIMER .
  inc MAP{Location, SemanticValue} .
  inc MAP{ProcessId, Nat} .
  inc POU-DEF .
  inc JOBS .
  inc STREAM .
  inc COMPONENT .
  inc LTLFORMULA .
  inc VSET .
  inc LOG .

  op log : Log -> KConfig [ctor] .
  op tindex : Nat -> KConfig [ctor] .
  ops inVars outVars : SKSet -> KConfig [ctor] . 
  op active : ProcessId -> KConfig [ctor] .
  op randomSeed : Nat -> KConfig [ctor] .
  op globalTime : Nat Nat -> KConfig [ctor] .
  op globalVars : VSet -> KConfig [ctor] .
  op env : Env -> KConfig [ctor] .
  op store : Map{Location, SemanticValue} -> KConfig [ctor] .  
  op POUDef : POUDefinition -> KConfig [ctor] .
  op PARDef : Pid VarSecTypePairList Stmt -> KConfig [ctor] .
  op ins : KConfig -> KConfig [ctor] . --- ProcessId Pid Timer Env
  op inss : KConfig -> KConfig [ctor] . 
  op cycleTime : Nat -> KConfig [ctor] .
  op constraints : BoolSemanticVal -> KConfig [ctor] .
  op recentAction : Qid -> KConfig [ctor] .
  op streamVars : StreamVars -> KConfig [ctor] .

  op interval : Map{ProcessId, Nat} -> KConfig [ctor] .
  op futureTS : TaskSet -> KConfig [ctor] .
  op pQueue : TaskList -> KConfig [ctor] .

  op task : KConfig -> KConfig [ctor] . --- ProcessId K ProgramStack interval phase priority futureTS

  op maxES : TaskList ~> Nat .
  op minDL : TaskList ~> Nat .
  op minDL : TaskSet ~> Nat .

  op None : -> ProcessId [ctor] .

  ops inStream outStream : StreamMap -> KConfig [ctor] .

  op enumTypes : TypeDeclSet -> KConfig [ctor] .

  op maxTime : Nat -> KConfig [ctor] .
  op newVarIndex : Nat -> KConfig [ctor] .
  
  op LTLCondition : LTLFormula -> KConfig [ctor] .

  var LOC : ProcessId .
  var ENV : Env .
  var FBNAME : Pid .
  var REST INSS : KConfig .  
---
  op getInsEnv : ProcessId KConfig ~> Env .
  eq getInsEnv(LOC, ins(id(LOC) mem(ENV) REST) INSS) = ENV .

  op getInsType : ProcessId KConfig ~> Pid .
  eq getInsType(LOC, ins(id(LOC) fbtype(FBNAME) REST) INSS) = FBNAME .

  op initCond : ~> SemanticValue .
  op tv : Nat ~> SemanticValue .
  op botSpace : PExp ~> PExp .
  op botWrite : PExp SemanticValue ~> K .
endfm
