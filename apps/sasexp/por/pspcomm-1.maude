load /home/jlee/plc-release/scripts/../semantics/interpreter/environment 
load /home/jlee/plc-release/scripts/../libs/libcollection.maude
 

mod APP is 
inc PLC-CORE .
inc PLC-LIB .
ops projectFile envFile : -> StratonProject .
eq projectFile =
(
BEGINCONFIG
PROGRAMS
'WaterTank1 ;; 
PROGRAMSEND
SUBPROGRAMS
emptyProgramList
SUBPROGRAMSEND

TYPE
emptyTypeDecl
ENDTYPE



BEGINVAR
emptyVarDecl
ENDVAR


CycleTime: # 3
ENDCONFIG

BEGINPOUS
PROGRAM 'WaterTank1 
BEGINVAR
'P1_switch : BOOL : ##PRIV ; 
'P1 : DINT : ##PRIV ;
'comm : fbtype [ 'CONNECT ] : ##PRIV ; 
'send : fbtype [ 'USEND ] : ##PRIV ; 
ENDVAR

CODE
'comm ( TRUE, # "env" ) ;
IF ( NOT ('comm . 'VALID ) ) THEN 
return ; 
ENDIF ;
'P1 := boolUserInput ; 
'send ( TRUE , # "env" , # "rcvT1" , 'P1 ) ; 
@assertTime(# 0, # 1) ;
ENDCODE
ENDPROGRAM

ENDPOUS

) .

eq envFile =
(
BEGINCONFIG
PROGRAMS
'Env ;; 
PROGRAMSEND
SUBPROGRAMS
emptyProgramList
SUBPROGRAMSEND

TYPE
emptyTypeDecl
ENDTYPE



BEGINVAR
emptyVarDecl
ENDVAR


CycleTime: # 3
ENDCONFIG

BEGINPOUS
PROGRAM 'Env 
BEGINVAR
'signal1 : INT : ##PRIV ;
'water_level_t1 : INT : ##IN ;
'water_level_t2 : INT : ##IN ;
'pump_switch_t1 : INT : ##OUT ;
'comm1 : fbtype [ 'CONNECT ] : ##PRIV ; 
'rcvT1 : fbtype [ 'URCV ] : ##PRIV ;
ENDVAR

CODE
'comm1 ( TRUE , # "plc1" ) ; 
IF NOT ('comm1 . 'VALID) THEN 
return ; 
ENDIF ;

'rcvT1( TRUE, # "plc1", # "send") ; 
@assertTime(# 2, # 3) ;
'signal1 := ('rcvT1 . 'DATA) ;

'pump_switch_t1 := 'signal1 ;

ENDCODE
ENDPROGRAM
ENDPOUS

) .

  ops linkedFile linkedEnv : -> StratonProject .
  eq linkedFile = projectFile <-load- lib .
  eq linkedEnv = envFile <-load- lib .
  ops app env : -> KConfig .
  eq app = [[[ linkedFile ]]] .
  eq env = [[[ linkedEnv ]]] .
endm

mod MC is
  inc APP .
  inc COMMUNICATION . 

  op t : -> Var [ctor] .
  op init : ~> World .
  eq minDelay = [(1/1).Real] .
 ceq log(LOG:Log) = log(emptyLog) if LOG:Log =/= emptyLog .


  eq init =
{
< # "plc1" : PLCMachine | proc : app, timer : [(0).Integer], envTimer : 0, gen : 0, clock : 0,
                          senList : nilPExpList, 
                          actList : nilPExpList,
                          state : emptyMap,
                          flow : noDynamics >
< # "env" : PLCMachine | proc : env, timer : [(0).Integer], envTimer : 0, gen : 0, clock : 0,
                         senList : ('water_level_t1 , 'water_level_t2), 
                         actList : 'pump_switch_t1,
                         state : (('water_level_t1 ||-> [(7).NzNat]), ('water_level_t2 ||-> [(5).NzNat]),
                                  ('pump_switch_t1 ||-> [(0).Zero])),
                         flow : ('water_level_t1(t) = s['water_level_t1] - (s['pump_switch_t1] * v[t]) ;;
                                 'water_level_t2(t) = s['water_level_t2] + (s['pump_switch_t1] * v[t])) >

< link(# "plc1", # "env") : Channel | validity : false, buffer : emptyBuffer >
  cconst([(true).Boolean]) tconst([(true).Boolean]) tickTurn((false).Bool) tgen((0).Nat)
} .

  op X_X : Configuration -> World [ctor frozen] .
 ceq { < O:Oid : PLCMachine |  ATTRS:AttributeSet, clock : T:Nat > REST:Configuration }
   = X < O:Oid : PLCMachine |  ATTRS:AttributeSet, clock : T:Nat > REST:Configuration X
  if float(T:Nat) >= 3.0 .

endm 

smod POR is
  inc MC .

  strat internal @ Configuration .
  strat commu @ Configuration .
  strat allRules @ Configuration .
  strat porStep @ Configuration .
  strat indiv : Oid @ Configuration .

  sd internal := arrayLookup | array | iteTrue | iteFalse | IFTRUE | IFFALSE | IFFALSE-ELSIF | IFFALSE-ELSE | caseMatch | caseMatchRanged | caseNotMatch | caseNotMatchRanged | arrayArgBind .
  sd commu := discon-vol | sendData | rcvData | rcv-fail | rcv-noMsg .
  sd allRules := internal | commu | tick | start .

  var I : Oid .
  sd indiv(I) := matchrew {< I : PLCMachine | proc : P:KConfig, ATTRS:AttributeSet > CONF:Configuration} by P:KConfig using internal .

  sd porStep := (start ? idle : ((indiv(# "env") ? idle : indiv(# "plc1")) ? idle : (commu ? idle : tick))) .

  strat goalState @ Configuration .
  sd goalState := match {< # "env" : PLCMachine | state : (('water_level_t1 ||-> SM:SemanticValue), ('water_level_t2 ||-> SM2:SemanticValue), REST:Map{PExp, SemanticValue}), ATTRS:AttributeSet > CONF:Configuration}
                  s.t. checkSAT(SM:SemanticValue < [(2).NzNat] OR SM:SemanticValue > [(30).NzNat]
                    OR SM2:SemanticValue < [(2).NzNat] OR SM2:SemanticValue > [(30).NzNat]) .

  strat porStar @ Configuration .
  sd porStar := (porStep *) .

  strat noPor @ Configuration .
  sd noPor := (allRules *) .
endsm


srew [1] init using (porStep * ; fail) .

eof

search [1]  init
=>*
{< # "env" : PLCMachine | state : (('water_level_t1 ||-> SM:SemanticValue), ('water_level_t2 ||-> SM2:SemanticValue),
                                     ('pump_switch_t1 ||-> SM3:SemanticValue)), ATTRS:AttributeSet > R:Configuration } 
such that checkSAT(SM:SemanticValue < [(2).NzNat] OR SM:SemanticValue > [(30).NzNat]
                   OR SM2:SemanticValue < [(2).NzNat] OR SM2:SemanticValue > [(30).NzNat]) .


